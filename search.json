[{"title":"K8s集群部署","url":"/2025/12/10/k8s%E9%83%A8%E7%BD%B2/","content":"环境说明：三台Ubuntu24.04.2，IP分别为128、129、130，无法科学上网\n1、主机名配置与解析\n\n修改主机名\n配置hosts文件\nping验证\n\n2、关闭swap空间\n\n临时关闭 swapoff -a \n永久关闭 vim /etc/fstab 注释包含 swpa 的行\nfree -h 或 swapon -show 验证\n\n3、时间同步\n\n查看当前时间&#x2F;时区 timedatectl status \n更改时区 timedatectl set-timezone Asia/Shanghai \n更改时间 \n手动更改 date -s &quot;2025-12-03 14:30:00&quot; \n自动同步 systemctl restart systemd-timesyncd 重启服务会立即和配置文件 &#x2F;etc&#x2F;systemd&#x2F;timesyncd.conf 中指定的ntp服务器同步下\n\n\n\n4、防火墙等安全策略\n\n临时关闭防火墙或配置放行规则\nUbuntu默认不使用SELinux（使用AppArmor），但AppArmor不会影响K8s实验\n\n5、内核模块与参数\n# 1. 将需要加载的内核模块加入配置文件cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.confoverlaybr_netfilterEOF# 2. 立即加载模块sudo modprobe overlaysudo modprobe br_netfilter# 3. 配置内核参数并持久化cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.confnet.bridge.bridge-nf-call-iptables  = 1  #开启桥接流量经过 iptables 的检查，确保 Service 的流量规则生效net.bridge.bridge-nf-call-ip6tables = 0  #同上，针对 IPv6 流量net.ipv4.ip_forward                 = 1  #开启 Linux 主机的 IPv4 路由转发，使 Pod 可以跨节点通信net.ipv6.conf.all.forwarding        = 0net.ipv4.vs.conn_reuse_mode         = 0  #调整IPVS连接复用行为，推荐在系统内核&gt;5.9时启用，在大型集群中性能更好EOF# 4. 使配置生效（无需重启）sudo sysctl --system\n\n6、SSH免密登录（仅master节点，非必要，仅推荐）7、安装容器运行时CRI（containerd）\n\n在线安装\n添加Docker官方GPG密钥（用于验证软件包）\n添加阿里云提供的Docker CE软件源\n安装containerd\n修改配置文件\n\n\n\n# 添加Docker官方GPG密钥sudo mkdir -m 0755 -d /etc/apt/keyringssudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.ascsudo chmod a+r /etc/apt/keyrings/docker.asc# 添加阿里云的Docker CE仓库镜像echo &quot;deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null# 更新源并安装containerdsudo apt-get updatesudo apt-get install -y containerd.io# 备份原配置cp /etc/containerd/config.toml /etc/containerd/config.toml.bak# 生成包含CRI插件的完整配置文件containerd config default &gt; /etc/containerd/config.toml# 修改配置文件disabled_plugins = []  #确保括号内不含criSystemdCgroup = true  #使用systemd作为cgroup驱动sandbox = &quot;registry.aliyuncs.com/google_containers/pause:3.10.1&quot;  #Kubernetes需要使用pause镜像作为sandbox容器# 验证 grep disabled_plugins /etc/containerd/config.tomlgrep SystemdCgroup /etc/containerd/config.tomlgrep sandbox /etc/containerd/config.toml# 使用systemd管理containerdsudo systemctl daemon-reloadsudo systemctl enable --now containerdsudo systemctl restart containerdsudo systemctl status containerd# 镜像加速配置参考https://xuanyuan.cloud/usage/containerd\n\n离线安装  1.下载二进制包离线安装  2.下载rpm&#x2F;deb包离线安装\n\n8、安装containerd 的管理包 crictl\n## 选择版本 https://github.com/kubernetes-sigs/cri-tools/releases wget https://github.com/kubernetes-sigs/cri-tools/releases/download/v1.34.0/crictl-v1.34.0-linux-amd64.tar.gz tar xvf crictl-v1.23.0-linux-amd64.tar.gz -C /usr/local/bin cat &lt;&lt;EOF&gt; /etc/crictl.yamlruntime-endpoint: unix:///run/containerd/containerd.sockimage-endpoint: unix:///run/containerd/containerd.socktimeout: 10debug: falseEOF # 验证crictl pull hello-worldcrictl images\n\n\n9、安装kubeadm, kubelet和kubectl\n# 安装依赖sudo apt install -y apt-transport-https ca-certificates curl gpg conntrack# 添加Kubernetes官方仓库curl -fsSL https://pkgs.k8s.io/core:/stable:/v1.31/deb/Release.key | sudo gpg --dearmor -o /etc/apt/keyrings/kubernetes-apt-keyring.gpgecho &#x27;deb [signed-by=/etc/apt/keyrings/kubernetes-apt-keyring.gpg] https://pkgs.k8s.io/core:/stable:/v1.31/deb/ /&#x27; | sudo tee /etc/apt/sources.list.d/kubernetes.listsudo apt update# 安装kubeadm、kubelet和kubectlsudo apt install -y kubelet kubeadm kubectl# 锁定版本防止自动更新sudo apt-mark hold kubelet kubeadm kubectl# 启用kubelet服务sudo systemctl enable --now kubelet# 验证安装kubeadm versionkubectl version --client\n\n10、使用kubeadm初始化集群\n# 在主节点执行kubeadm init \\  --apiserver-advertise-address=192.168.19.128 \\  --pod-network-cidr=10.244.0.0/16 \\  --service-cidr=10.96.0.0/12 \\  --image-repository=registry.aliyuncs.com/google_containers \\  --cri-socket=unix:///var/run/containerd/containerd.sock \\# 主节点和工作节点分别执行输入后的提示信息！！！# 在主节点验证kubectl get nodeskubectl get pods -A\n\n11、安装 CNI 网络插件\n#下载并修改Calico配置文件使用国内镜像curl -O https://raw.githubusercontent.com/projectcalico/calico/v3.28.0/manifests/calico.yaml##替换镜像为国内镜像源sed -i &#x27;s|docker.io/calico/|docker.m.daocloud.io/calico/|g&#x27; calico.yamlsed -i &#x27;s|quay.io/calico/|quay.m.daocloud.io/calico/|g&#x27; calico.yaml#应用修改后的配置文件kubectl apply -f calico.yaml#检查状态kubectl get pods -n kube-system -w  #后续升级Calico##重新下载新版本的calico.yamlcurl -O https://raw.githubusercontent.com/projectcalico/calico/&lt;新版&gt;/manifests/calico.yaml#修改镜像源后应用kubectl apply -f calico.yaml\n\n12、部署一个pod看看\ncat &gt; nginx.yaml &lt;&lt; EOFapiVersion: apps/v1kind: Deploymentmetadata:  name: nginx-deployment  labels:    app: nginxspec:  replicas: 2  selector:    matchLabels:      app: nginx  template:    metadata:      labels:        app: nginx    spec:      containers:      - name: nginx        image: swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/library/nginx:1.23.2        ports:        - containerPort: 80---apiVersion: v1kind: Servicemetadata:  name: nginx-service  labels:    app: nginxspec:  type: NodePort  selector:    app: nginx  ports:    - port: 80      targetPort: 80      protocol: TCP      nodePort: 30080      name: nginxEOFkubectl apply -f nginx.yamlkubectl get podkubectl get svc\n\n\n\n9和10为安装方式（kubeadm），官方提供的“半自动化部署工具”。（目标是让部署一个符合“最佳实践”的、标准的 Kubernetes 集群变得快速和简单）\n\n工作原理：kubeadm 本身并不直接提供 Kubernetes 的核心组件（如 kubelet、kube-apiserver 等）。它做了以下几件事：1、检查环境：确保服务器满足所有前置条件（如讨论的1-8步）2、拉取镜像：从互联网（通常是谷歌的镜像仓库 k8s.gcr.io，现在部分转向 registry.k8s.io）下载所有必需的 Kubernetes 核心组件镜像。3、生成证书：为集群各个组件之间的安全通信生成所有必要的证书和密钥。4、生成静态 Pod 清单：在 Master 节点上，它会将 kube-apiserver, kube-controller-manager, kube-scheduler 等组件的部署文件（称为 Static Pod Manifest）写入 &#x2F;etc&#x2F;kubernetes&#x2F;manifests 目录，然后由该节点上的 kubelet 直接启动和管理这些 Pod。5、配置 kubelet：与节点上的 kubelet 进程通信，对其进行配置。6、生成加入令牌：生成一个安全的令牌，让 Worker 节点可以加入到集群中。\n\nkubeadm 在底层仍然是使用二进制的容器镜像来运行各个组件，但它极大地简化了手动配置的复杂性。\n\n其他安装方式：二进制、全自动化部署工具、托管服务\n","categories":["运维"],"tags":["kubernetes","k8s","容器编排"]},{"title":"Hexo+Github==>个人博客","url":"/2024/09/09/Hexo+Github=%3E%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","content":"hexo 和 github 搭建个人博客的思路梳理1、下载 node.jshttps://nodejs.org/zh-cn\n2、下载 githttps://git-scm.com/downloads\n验证是否下载成功，管理员运行 cmd 输入以下三条命令\nnode -vnpm -vgit -v\n\n3、下载 hexonpm install hexo-cli -g\n\n4、搭建仓库名称格式：仓库名称.github.io\n勾选 Public\n勾选 Add a README file\n拉到下面点击 create 创建\n5、生成SSH Keys进入任意文件夹，右键空白处然后点Git bash here,输入\nssh-keygen -t rsa -C &quot;邮件地址&quot;\n\n然后敲4次Enter然后进入C:\\Users\\用户名，在里面进入.ssh文件用记事本打开里面的id_rsa.pub,全选复制里面的代码然后打开github进入用户设置，找到SSH keys新建SSH keys，名称随意，在下面粘贴代码，然后创建测试是否成功在git bash中输入\nssh -T git@github.com\n\n回车，然后再输入 yes\n6、本地部署在喜欢位置新建博客文件夹，进入此文件夹，右键打开终端，输入\nhexo init\n\n然后依次输入\nhexo g\t# 生成hexo s\t# 预览\n\n因为国内与github连接不稳定，如果不成功的话就等等再试，可以科学上网最好现在就可以复制生成的链接进入浏览器预览博客啦！！！验证完后，回到命令行，ctrl+c 关闭预览\n7、上线博客进入之前的Blog文件夹，打开_config.yml编辑 url 段落\n# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://76-s.github.io\n\n拉到最下面将deploy后面的全注释下，复制粘贴这段\ndeploy:type: gitrepo:  github: git@github.com:76-s/76-s.github.io.gitbranch: mainmessage: &quot;V1.7.0&quot;\n\n注意缩进格式：每行前面都有两个空格不要删，每个冒号后面都有个空格也不要删！去 github 之前生成的仓库页面，点 code，复制链接将其粘贴到编辑器中的 repo：后面然后保存退出回到博客文件夹，进入终端安装自动部署发布工具\nnpm install hexo-deployer-git --save\n\n然后在Blog文件夹右键打开终端，依次输入\nhexo g\t# 生成hexo d\t# 上传\n\n\n如果是第一次使用git的话会需要配置git config --global user.email &quot;你的邮箱&quot;git config --global user.name &quot;你的名字&quot;配置完后再 hexo d 上传在跳出来的窗口内进行登录接下来就成功把本地内容上传到github了上传成功以后，就算是搭建好了！上自己的网址看看吧网址是我们之前设的仓库名：用户名.github.io\n\n文章摘自🔗：https://blog.fiveth.cc/p/bb32/#%E5%87%86%E5%A4%87%E5%B7%A5%E5%85%B7\n","categories":["博客"],"tags":["Blog"]},{"title":"对称秘钥和非对称秘钥","url":"/2025/05/22/%E5%AF%B9%E7%A7%B0%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/","content":"对称加密和非对称加密对称加密对称加密使用同一个秘钥来进行加密和解密对称加密算法有：RC4、DES、3DES、AES 等加密算法根据同一个秘钥将明文加密成密文，或将密文解密成明文 \n\n  \n\n\n\n问题来了对称秘钥如果明文传输，可以被第三方拿到，使得第三方也可以解密密文对称秘钥如果密文传输，接收端如何解密秘钥\n\n非对称加密非对称加密使用公钥和私钥两种秘钥，它们并不是同一个秘钥公钥用来加密明文，私钥用来解密密文公钥一般是公开的，都能拿到，私钥只有接收端才有，不公开非对称加密算法有：RSA、DH 等\n\n非对称加密的加解密速度比对称加密要慢很多\n\n工作原理：发送端使用公钥加密，接收端使用私钥解密；公钥和私钥由接收端生成，公钥明文传输给发送端，发送端收到后使用公钥将数据加密后发送到接收端，接收端使用私钥解密，公钥被第三方截获也没关系，因为第三方没有私钥\n\n  \n\n\n\n\n\n混合加密对称加密不能安全的传输密钥，但是加解密速度块非对陈加密可以安全的传输密钥，但是加解密速度慢🤔🤔使用非对称加密解决对称秘钥的传输问题，使用对称加密传输数据\n\nSSL&#x2F;TLS 使用的就是混合加密\n\n\n  \n\n","categories":["技术分享"],"tags":["网络安全"]}]