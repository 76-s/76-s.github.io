{"meta":{"title":"阿帅","subtitle":"","description":"这是一个关于技术分享、生活感悟和创意灵感的博客。","author":"byte76","url":"https://Jiang07Shuai06.github.io","root":"/"},"pages":[{"title":"","date":"2024-12-22T03:25:02.750Z","updated":"2024-12-22T03:25:02.750Z","comments":true,"path":"about/index.html","permalink":"https://jiang07shuai06.github.io/about/index.html","excerpt":"","text":"🌹🌹😁😃 ⛷️💫"},{"title":"我的朋友们","date":"2024-10-11T11:48:27.035Z","updated":"2024-09-20T04:38:41.238Z","comments":true,"path":"friends/index.html","permalink":"https://jiang07shuai06.github.io/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"分类","date":"2024-12-22T02:45:03.000Z","updated":"2024-12-22T02:46:40.212Z","comments":true,"path":"categories/index.html","permalink":"https://jiang07shuai06.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-05-13T06:16:07.000Z","updated":"2024-12-22T03:13:56.308Z","comments":true,"path":"links/index.html","permalink":"https://jiang07shuai06.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2024-12-22T03:45:14.000Z","updated":"2024-12-22T03:21:46.428Z","comments":true,"path":"tags/index.html","permalink":"https://jiang07shuai06.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2023-05-14T03:45:14.000Z","updated":"2024-12-22T03:26:00.812Z","comments":true,"path":"masonry/index.html","permalink":"https://jiang07shuai06.github.io/masonry/index.html","excerpt":"","text":""}],"posts":[{"title":"HTTP基础概念","slug":"HTTP","date":"2024-12-24T02:37:22.519Z","updated":"2024-12-24T12:30:31.672Z","comments":true,"path":"2024/12/24/HTTP/","permalink":"https://jiang07shuai06.github.io/2024/12/24/HTTP/","excerpt":"","text":"HTTP超文本传输协议（HTTP）是一个用于传输超媒体文档（例如HTML）的应用层协议。它是为了Web浏览器与Web服务器之间的通信而设计的，但也可以用于其他目的（例如API通信）。HTTP是无状态协议，这意味着服务器不会在两个请求之间保留任何数据（状态）。 什么是HTTP请求？HTTP请求是客户端（比如浏览器）向服务器请求获取资源（如网页、图片、文件等）时发送的消息。包含如下几个关键部分： 请求行：包含请求方法（如 GET 用于获取资源、POST用于提交数据）、请求的 URL（统一资源定位符，指定要访问的资源位置）和 HTTP 协议版本。 请求头：包含一些额外的信息，像用户代理（表明请求的客户端类型）、接受的内容类型（如接受 HTML、JSON 等）、缓存控制信息等，用于告诉服务器更多关于请求的细节。 请求体（可选）：主要用于 POST 等请求方法，在其中放置要发送给服务器的数据，例如表单数据。 首先要明确，不是所有的 HTTP 请求方法都使用请求体。最常用于发送请求体的方法是 POST 和 PUT。 POST 方法通常用于向服务器提交数据来创建新的资源。例如，当用户在网页上填写一个注册表单并提交时，浏览器会使用 POST 方法将表单数据发送到服务器的注册接口。 PUT 方法主要用于更新服务器上已有的资源。假设一个在线文档编辑应用，用户修改了文档内容后，点击保存，应用可能会使用 PUT 方法将更新后的文档内容发送到服务器来更新文档资源。 http请求方法在 HTTP 通信过程中，每个 HTTP请求报文中都会包含一个 HTTP请求方法，用于告知客户端向服务器端请求执行某些具体的操作，下面列举几项常用的 HTTP请求方法 HTTP 请求方法 描述 GET 用于客户端请求指定资源信息，并返回指定资源实体 HEAD 和 GET 相似，但其不需要服务器响应请求的资源，而返回响应首部（只需要响应首部即可，就是告诉我有或者没有，不需要缓存界面给我） POST 基于HTML表单向服务器提交数据，服务i去通常需要存储此数据，通常存放在 MySQL 这种关系型数据库中 PUT 与 GET 相反，是向服务器发送资源的，服务器通常需要存储次资源，这就好比你要把一个新的商品送到商店并让商店存储起来。 DELETE 请求服务器端删除URL指定的资源 MOVE 请求服务器将指定的页面移至另一个网络地址 OPTIONS 探测服务器端对请求的URL所支持使用的请求方法 TRACE 跟踪一次请求中间所经历的代理服务器、防火墙或网关等。主要用于调试。 扩展：推荐一款功能强大的的 API开发和测试工具—— postman http协议版本http 0.9：最初的版本，仅支持 GET 方法，主要用于获取 HTML 文档，没有其他的概念，响应也很简单，只会返回 HTML 文档内容，没有状态码、响应头这些内容。 http 1.0：相较于0.9版本新增了多种请求方法，如 POST、HEAD等。引入了请求头和响应头，用于传递关于请求和响应的更多信息；例如，通过请求头中的 “Accept” 字段，客户端可以告诉服务器它能够接受的内容类型；响应头中的 “Content - Type” 字段则告知客户端返回内容的类型。支持多种内容类型，包括文本、图像、音频等多种格式的文件传输。 http 1.1： 目前广泛使用的版本之一，在1.0版本中，每次请求&#x2F;响应完成后，连接就会关闭。而1.1版本中允许在一次 TCP 连接中进行多次请求&#x2F;响应，减少了建立和关闭连接的开销，提高了网络传输效率。新增了更多的请求方法，如 PUT、DELETE 等。引入了管道化技术，允许客户端在等待一个请求的响应时发送下一个请求。不过，管道化在实际应用中因为一些复杂的原因（如请求顺序依赖等）没有得到广泛使用。 http 2.0：采用二进制格式进行数据传输，相比于1.1版本的文本格式，二进制格式更高效，解析速度更快。支持头部压缩，通过通过 HPB 算法压缩头部，减少传输量。多路复用是2.0版本的核心特性之一，它允许在一个 TCP 连接上同时传输多个请求和响应，这些请求和响应可以交错进行，而不需要像1.1版本那样排队等待。 什么是 HTTP 响应？HTTP 响应是服务器对客户端 HTTP 请求的回复消息。当客户端（如浏览器）向服务器发送请求，请求获取网页、文件或执行某种操作后，服务器会处理该请求，并返回一个 HTTP 响应来告知客户端请求的结果。组成部分：状态码：这是 HTTP 响应中非常关键的部分，它是一个三位数字的代码，用于表示服务器对请求的处理状态。例如，最常见的状态码 200，表示请求成功，服务器已成功处理并返回请求的资源。而 404 状态码则表示请求的资源未找到，可能是客户端请求的 URL 有误或者服务器上不存在该资源。另外还有 500 状态码，通常意味着服务器在处理请求时发生了内部错误。 响应头：响应头包含了关于响应的各种附加信息。比如 “Content - Type” 字段，它告诉客户端返回内容的类型，如 “text&#x2F;html” 表示返回的是 HTML 文档，“application&#x2F;json” 表示返回的是 JSON 格式的数据。还有 “Content - Length” 字段，用于指示响应体的长度（字节数）。此外，响应头还可能包含缓存控制信息（如 “Cache - Control”），用于指导客户端是否缓存以及如何缓存响应内容。 响应体：响应体是服务器返回的实际内容，是客户端真正需要的部分。如果客户端请求的是一个网页，那么响应体就是网页的 HTML 代码；如果请求的是一张图片，响应体就是图片的二进制数据；若请求的是一个 API 接口获取数据，响应体可能是 JSON 或 XML 格式的数据，这些数据包含了客户端所请求的信息。 http的状态码 状态码 说明 1XX 信息性状态码 2XX 成功状态码 3XX 重定向状态码 4XX 客户端错误 5XX 服务端错误 Web客户端访问Web服务器的工作流程（以网络浏览器为例）导航和启动用户在浏览器中输入网址或者点击其他通信中的链接后，浏览器通过 DNS 查找网址并将请求发送到该网址 客户端向服务器发送 HTTP 请求报文客户端（如浏览器）构建一个请求报文发送给 Web 服务器，请求报文的第一行标识了网站的根页面，指示了HTTP的版本（1.1&#x2F;1.0&#x2F;…），还有请求实体（如浏览器）的信息。请求报文发送到Web服务器后，即可由服务器读取并生成响应。 服务器将 HTTP 响应发回给客户端Web服务器收到请求后，就会生成响应报文并将其返回给浏览器（客户端），浏览器接收并读取响应报文。报文的第一行通常是响应代码如 “200 OK”，表示 Web服务器可以成功响应请求。HTTP响应报文确切再现了请求报文的格式，并包含一系列成为“响应标头”的行，这些行提供有关响应的信息。 浏览器呈现报文浏览器呈现响应报文，并在浏览器中显示网页 衡量一个 web网址的访问量指标：pv、uv、ippv：网站的点击量uv：网站的访问用户数——COOKIE，cookie值相同的表示是一个用户ip：网站的访问ip数，即有多少台客户机访问","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiang07shuai06.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"https://jiang07shuai06.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"author":"byte76"},{"title":"Hexo+Github==>个人博客","slug":"Hexo-Github-个人博客","date":"2024-10-20T08:17:35.000Z","updated":"2024-12-29T03:34:58.470Z","comments":true,"path":"2024/10/20/Hexo-Github-个人博客/","permalink":"https://jiang07shuai06.github.io/2024/10/20/Hexo-Github-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"这篇文章是对于使用 hexo 和 github 搭建个人博客的思路梳理1、下载 node.jshttps://nodejs.org/zh-cn 2、下载 githttps://git-scm.com/downloads 验证是否下载成功，管理员运行 cmd 输入以下三条命令 123node -vnpm -vgit -v 3、下载 hexo1npm install hexo-cli -g 4、搭建仓库名称格式：仓库名称.github.io 勾选 Public 勾选 Add a README file 拉到下面点击 create 创建 5、生成SSH Keys进入任意文件夹，右键空白处然后点Git bash here,输入 1ssh-keygen -t rsa -C &quot;邮件地址&quot; 然后敲4次Enter⌨️然后进入C:\\Users\\用户名，在里面进入.ssh文件用记事本打开里面的id_rsa.pub,全选复制里面的代码然后打开github进入用户设置，找到SSH keys新建SSH keys，名称随意，在下面粘贴代码，然后创建测试是否成功在git bash中输入 1ssh -T git@github.com 回车，然后再输入 yes 6、本地部署在喜欢位置新建文件Blog，然后进入文件夹右键空白处然后点 Git bash here，输入 1hexo init 然后依次输入 12hexo g # 生成hexo s # 预览 （如果不成功的话就重复直到成功，因为国内与github连接不稳定）现在就可以复制生成的链接进入浏览器看到我们生成的本地服务器了然后回到命令行，ctrl+c 关闭 7、上线博客进入之前的Blog文件夹，用记事本打开_config.yml编辑 url 段落 123# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://Jiang07Shuai06.github.io 拉到最下面将deploy后面的全删掉，复制粘贴这段 123type: gitrepository: branch: main 注意缩进格式：每行前面都有两个空格不要删，每个冒号后面都有个空格也不要删！去 github 之前生成的仓库页面，点 code，复制 https链接将其粘贴到我们记事本中的 repository：后面然后保存退出回到博客文件夹，git bash安装自动部署发布工具 1npm install hexo-deployer-git --save 然后在Blog文件夹右键打开git bash，依次输入 12hexo g # 生成hexo d # 上传 如果是第一次使用git的话会需要配置git config --global user.email &quot;你的邮箱&quot;git config --global user.name &quot;你的名字&quot;配置完后再 hexo d 上传在跳出来的窗口内进行登录接下来我们就成功把本地内容上传到github了上传成功以后，我们就算搭建好了！上自己的网址看看吧网址是我们之前设的仓库名：用户名.github.io 文章参考🔗：https://blog.fiveth.cc/p/bb32/#%E5%87%86%E5%A4%87%E5%B7%A5%E5%85%B7","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiang07shuai06.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://jiang07shuai06.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"天气预报自动推送","slug":"天气预报推送","date":"2024-10-07T09:29:17.000Z","updated":"2024-10-26T02:34:44.175Z","comments":true,"path":"2024/10/07/天气预报推送/","permalink":"https://jiang07shuai06.github.io/2024/10/07/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E6%8E%A8%E9%80%81/","excerpt":"","text":"一、申请微信测试公众号（https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login） 获取到这四个值 appID, appSecret, openId, template_id 想让谁收消息，谁就用微信扫二维码，刷新页面后即出现在用户列表，获取微信号（openId） 新增测试模板获得 template_id（模板ID） 天气模板： 123456今天：&#123;&#123;date.DATA&#125;&#125;地区：&#123;&#123;region.DATA&#125;&#125;天气：&#123;&#123;weather.DATA&#125;&#125;气温：&#123;&#123;temp.DATA&#125;&#125;风向：&#123;&#123;wind_dir.DATA&#125;&#125;对你说的话：&#123;&#123;today_note.DATA&#125;&#125; 课程表模板： 1消息：&#123;&#123;message.DATA&#125;&#125; 二、配置代码 将上面获得的几个值填入代码这几行，启动即可 12345678appID = &quot;&quot;appSecret = &quot;&quot;#收信人ID即 用户列表中的微信号，见上文openId = &quot;&quot;# 天气预报模板IDweather_template_id = &quot;&quot;# 时间表模板IDtimetable_template_id = &quot;&quot; 定时任务（根据需求进行修改这几行） 12345schedule.every().day.at(&quot;08:00&quot;).do(weather_report, &quot;北京&quot;)# schedule.every().monday.at(&quot;13:30&quot;).do(timetable, &quot;还有15分钟开始下午的课程&quot;)while True: schedule.run_pending() time.sleep(1) 完成代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166# 安装依赖 pip3 install requests html5lib bs4 scheduleimport timeimport requestsimport jsonimport schedulefrom bs4 import BeautifulSoup# 从测试号信息获取appID = &quot;wx1c904b832908e3d7&quot;appSecret = &quot;024e7a99b9bd93e4ec2ba0e61cb99869&quot;#收信人ID即 用户列表中的微信号，见上文openId = &quot;oLg156sEhzpHX3f6OKG6HaCTid9s&quot;# 天气预报模板IDweather_template_id = &quot;T00eYDomN3GOBXOTqTYhX27Nqp-vCdDO2xHKAK1ElH8&quot;# 时间表模板IDtimetable_template_id = &quot;kg29LwRP6--uo6Xq3mm-aRyJFaF_Pe2SsnUjYq23YpA&quot;def get_weather(my_city): urls = [&quot;http://www.weather.com.cn/textFC/hb.shtml&quot;, &quot;http://www.weather.com.cn/textFC/db.shtml&quot;, &quot;http://www.weather.com.cn/textFC/hd.shtml&quot;, &quot;http://www.weather.com.cn/textFC/hz.shtml&quot;, &quot;http://www.weather.com.cn/textFC/hn.shtml&quot;, &quot;http://www.weather.com.cn/textFC/xb.shtml&quot;, &quot;http://www.weather.com.cn/textFC/xn.shtml&quot; ] for url in urls: resp = requests.get(url) text = resp.content.decode(&quot;utf-8&quot;) soup = BeautifulSoup(text, &#x27;html5lib&#x27;) div_conMidtab = soup.find(&quot;div&quot;, class_=&quot;conMidtab&quot;) tables = div_conMidtab.find_all(&quot;table&quot;) for table in tables: trs = table.find_all(&quot;tr&quot;)[2:] for index, tr in enumerate(trs): tds = tr.find_all(&quot;td&quot;) # 这里倒着数，因为每个省会的td结构跟其他不一样 city_td = tds[-8] this_city = list(city_td.stripped_strings)[0] if this_city == my_city: high_temp_td = tds[-5] low_temp_td = tds[-2] weather_type_day_td = tds[-7] weather_type_night_td = tds[-4] wind_td_day = tds[-6] wind_td_day_night = tds[-3] high_temp = list(high_temp_td.stripped_strings)[0] low_temp = list(low_temp_td.stripped_strings)[0] weather_typ_day = list(weather_type_day_td.stripped_strings)[0] weather_type_night = list(weather_type_night_td.stripped_strings)[0] wind_day = list(wind_td_day.stripped_strings)[0] + list(wind_td_day.stripped_strings)[1] wind_night = list(wind_td_day_night.stripped_strings)[0] + list(wind_td_day_night.stripped_strings)[1] # 如果没有白天的数据就使用夜间的 temp = f&quot;&#123;low_temp&#125;——&#123;high_temp&#125;摄氏度&quot; if high_temp != &quot;-&quot; else f&quot;&#123;low_temp&#125;摄氏度&quot; weather_typ = weather_typ_day if weather_typ_day != &quot;-&quot; else weather_type_night wind = f&quot;&#123;wind_day&#125;&quot; if wind_day != &quot;--&quot; else f&quot;&#123;wind_night&#125;&quot; return this_city, temp, weather_typ, winddef get_access_token(): # 获取access token的url url = &#x27;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&#123;&#125;&amp;secret=&#123;&#125;&#x27; \\ .format(appID.strip(), appSecret.strip()) response = requests.get(url).json() print(response) access_token = response.get(&#x27;access_token&#x27;) return access_tokendef get_daily_love(): # 每日一句情话 url = &quot;https://api.lovelive.tools/api/SweetNothings/Serialization/Json&quot; r = requests.get(url) all_dict = json.loads(r.text) sentence = all_dict[&#x27;returnObj&#x27;][0] daily_love = sentence return daily_lovedef send_weather(access_token, weather): # touser 就是 openID # template_id 就是模板ID # url 就是点击模板跳转的url # data就按这种格式写，time和text就是之前&#123;&#123;time.DATA&#125;&#125;中的那个time，value就是你要替换DATA的值 import datetime today = datetime.date.today() today_str = today.strftime(&quot;%Y年%m月%d日&quot;) body = &#123; &quot;touser&quot;: openId.strip(), &quot;template_id&quot;: weather_template_id.strip(), &quot;url&quot;: &quot;https://weixin.qq.com&quot;, &quot;data&quot;: &#123; &quot;date&quot;: &#123; &quot;value&quot;: today_str &#125;, &quot;region&quot;: &#123; &quot;value&quot;: weather[0] &#125;, &quot;weather&quot;: &#123; &quot;value&quot;: weather[2] &#125;, &quot;temp&quot;: &#123; &quot;value&quot;: weather[1] &#125;, &quot;wind_dir&quot;: &#123; &quot;value&quot;: weather[3] &#125;, &quot;today_note&quot;: &#123; &quot;value&quot;: get_daily_love() &#125; &#125; &#125; url = &#x27;https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=&#123;&#125;&#x27;.format(access_token) print(requests.post(url, json.dumps(body)).text)def send_timetable(access_token, message): body = &#123; &quot;touser&quot;: openId, &quot;template_id&quot;: timetable_template_id.strip(), &quot;url&quot;: &quot;https://weixin.qq.com&quot;, &quot;data&quot;: &#123; &quot;message&quot;: &#123; &quot;value&quot;: message &#125;, &#125; &#125; url = &#x27;https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=&#123;&#125;&#x27;.format(access_token) print(requests.post(url, json.dumps(body)).text)def weather_report(city): # 1.获取access_token access_token = get_access_token() # 2. 获取天气 weather = get_weather(city) print(f&quot;天气信息： &#123;weather&#125;&quot;) # 3. 发送消息 send_weather(access_token, weather)def timetable(message): # 1.获取access_token access_token = get_access_token() # 3. 发送消息 send_timetable(access_token, message)if __name__ == &#x27;__main__&#x27;: weather_report(&quot;河北&quot;) # timetable(&quot;第二教学楼十分钟后开始英语课&quot;) # schedule.every().day.at(&quot;08:00&quot;).do(weather_report, &quot;北京&quot;) # schedule.every().monday.at(&quot;13:30&quot;).do(timetable, &quot;还有15分钟开始下午的课程&quot;) #while True: # schedule.run_pending() # time.sleep(1) 原创文档链接：https://www.bilibili.com/read/cv28928153/ 原创视频链接：https://www.bilibili.com/video/BV1Ng4y1r7EP/?spm_id_from=333.880.my_history.page.click&amp;vd_source=576ff0210b33e8823a0a538d3f79f11f","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiang07shuai06.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://jiang07shuai06.github.io/tags/Python/"}]},{"title":"外星人入侵","slug":"外星人入侵","date":"2024-10-04T11:05:33.000Z","updated":"2024-10-26T02:30:49.441Z","comments":true,"path":"2024/10/04/外星人入侵/","permalink":"https://jiang07shuai06.github.io/2024/10/04/%E5%A4%96%E6%98%9F%E4%BA%BA%E5%85%A5%E4%BE%B5/","excerpt":"","text":"遇到的问题及注意事项： 编写计分模块 scoreborad.py 时，变量引用错误，没搞清楚使用的是值传递还是引用传递 参考链接 https://blog.csdn.net/hohaizx/article/details/78427406 飞船数量与设置模块 settings.py 中的飞船设置相关 外星人、子弹、飞船移动速度以及幅度与设置模块 settings.py 中的 initialize_dynamic_settings 函数设置相关 参考资料及源码： 参考书籍《Python编程——从入门到实践》 参考教程链接 https://www.modb.pro/db/49581 通过百度网盘分享的文件：alien_invasion_2.0.zip 链接：https://pan.baidu.com/s/1NTkG7Mk_5sw4uzQLVU8ieQ?pwd=byte 提取码：byte","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiang07shuai06.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://jiang07shuai06.github.io/tags/Python/"}]}],"categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiang07shuai06.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"https://jiang07shuai06.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"博客","slug":"博客","permalink":"https://jiang07shuai06.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Python","slug":"Python","permalink":"https://jiang07shuai06.github.io/tags/Python/"}]}