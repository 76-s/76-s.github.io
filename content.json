{"meta":{"title":"阿帅","subtitle":"","description":"这是一个关于技术分享、生活感悟和创意灵感的博客。","author":"byte76","url":"https://Jiang07Shuai06.github.io","root":"/"},"pages":[{"title":"分类","date":"2024-12-22T02:45:03.000Z","updated":"2024-12-22T02:46:40.212Z","comments":true,"path":"categories/index.html","permalink":"https://jiang07shuai06.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2025-04-17T10:39:29.266Z","updated":"2025-04-17T10:39:29.266Z","comments":true,"path":"about/index.html","permalink":"https://jiang07shuai06.github.io/about/index.html","excerpt":"","text":"哈喽🫡，我是76，常驻地在北京，04年 “上线” 的真人“程序”平时喜欢旅游、追剧、捣鼓个人博客还有去王者峡谷溜达溜达"},{"title":"友情链接","date":"2020-05-13T06:16:07.000Z","updated":"2024-12-22T03:13:56.308Z","comments":true,"path":"links/index.html","permalink":"https://jiang07shuai06.github.io/links/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2024-10-11T11:48:27.035Z","updated":"2024-09-20T04:38:41.238Z","comments":true,"path":"friends/index.html","permalink":"https://jiang07shuai06.github.io/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"标签","date":"2024-12-22T03:45:14.000Z","updated":"2024-12-22T03:21:46.428Z","comments":true,"path":"tags/index.html","permalink":"https://jiang07shuai06.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2023-05-14T03:45:14.000Z","updated":"2024-12-22T03:26:00.812Z","comments":true,"path":"masonry/index.html","permalink":"https://jiang07shuai06.github.io/masonry/index.html","excerpt":"","text":""}],"posts":[{"title":"堡垒机(1) | 概念&部署","slug":"堡垒机-1-概念-部署","date":"2025-01-12T03:30:10.000Z","updated":"2025-01-12T04:31:06.481Z","comments":true,"path":"2025/01/12/堡垒机-1-概念-部署/","permalink":"https://jiang07shuai06.github.io/2025/01/12/%E5%A0%A1%E5%9E%92%E6%9C%BA-1-%E6%A6%82%E5%BF%B5-%E9%83%A8%E7%BD%B2/","excerpt":"","text":"简介堡垒机是一种用于单点登录、集中授权、访问控制和操作审计的安全设备，也被称为跳板机。它就像网络中的 “安全卫士”，主要作用是对内部网络中运维人员的操作进行集中管理和控制，是实现运维安全的核心设备。主要功能：身份认证、访问控制、操作审计、会话管理Jumpserver 是一款由python编写开源的跳板机（堡垒机）系统，实现了跳板机应有的功能。基于ssh协议来管理，客户端无需安装agent。&nbsp;在公司中，分配人员服务器权限也是相当方便，如：来一个新人，在Jumpserver分配Jumpserver账号即可，人员离职，在Jumpserver删掉人员账号即可。无需担心人员离职留下后门，当然前提是检查防火墙，只允许Jumpserver服务器有其他服务器的ssh的权限。目前市面上已经有很多jumpserver产品提供使用，这里就介绍最广泛的一款。官方网址：https://www.jumpserver.org/&nbsp; JumpServer 部署参考官方部署文档：https://docs.jumpserver.org/zh/master/install/setup_by_fast/&nbsp;这款也是基于docker运行的，不管一键部署，还是手动部署都是docker，手动部署区别主要是改密码、IP、端口自定义之类的。默认的其实已经很好没必要改了。相对来所，搭建还是比较容易的，官方脚本一步到位。&nbsp;由于魔法的原因可能会无法连接到 GitHub，这里可以考虑使用以下命令 1curl -sSL https://resource.fit2cloud.com/jumpserver/jumpserver/releases/latest/download/quick_start.sh | bash 注：4核8G （最低）且可以访问互联网的 64 位 Linux 主机 当然，如果需要离线安装也可以到下方 URI 获取软件包后，进行手动部署 https://community.fit2cloud.com/#/products/jumpserver/downloads 下面是我部署完成后显示的信息 &nbsp; 可以使用如下命令启动, 然后访问cd &#x2F;opt&#x2F;jumpserver-installer-v4.5.0.&#x2F;jmsctl.sh start 其它一些管理命令.&#x2F;jmsctl.sh stop.&#x2F;jmsctl.sh restart.&#x2F;jmsctl.sh backup.&#x2F;jmsctl.sh upgrade更多还有一些命令, 你可以 .&#x2F;jmsctl.sh –help 来了解 Web 访问http://192.168.241.66:80默认用户: admin 默认密码: ChangeMe 更多信息官方网站: https://www.jumpserver.org/官方文档: https://docs.jumpserver.org/","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiang07shuai06.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"堡垒机","slug":"堡垒机","permalink":"https://jiang07shuai06.github.io/tags/%E5%A0%A1%E5%9E%92%E6%9C%BA/"}]},{"title":"iptables(1) | iptables概念","slug":"iptables-1-iptables概念","date":"2025-01-06T03:29:01.000Z","updated":"2025-01-08T10:19:55.774Z","comments":true,"path":"2025/01/06/iptables-1-iptables概念/","permalink":"https://jiang07shuai06.github.io/2025/01/06/iptables-1-iptables%E6%A6%82%E5%BF%B5/","excerpt":"","text":"相关概念防火墙从逻辑上可以分为主机防火墙和网络防火墙 主机防火墙：针对单个主机进行防护。 网络防火墙：往往处于网络入口，针对于网络入口进行防护，服务于防火墙背后的本地局域网。 网络防火墙和主机防火墙并不冲突，可以理解为，网络防火墙主外（集体）， 主机防火墙主内（个人）。 防火墙从物理上可以分为硬件防火墙和软件防火墙 硬件防火墙：硬件防火墙是一种专门设计的网络安全设备，它基于硬件平台运行，性能高，成本高。 软件防火墙：软件防火墙是安装在计算机操作系统或网络设备操作系统中的软件程序。性能低，成本低。&nbsp; 关于iptables **iptables** 其实不是真正的防火墙，我们可以把它理解成一个客户端代理，用户通过iptables这个代理，将用户的安全设定执行到对应的”安全框架”中，这个”安全框架”才是真正的防火墙，这个框架的名字叫 **netfilter**。 netfilter 才是防火墙真正的安全框架（framework)，netfilter位于内核空间。 iptables 其实是一个命令行工具，位于用户空间，我们用这个工具操作真正的框架。 netfilter&amp;iptables 组成Linux平台下的包过滤防火墙，与大多数的Linux软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换（NAT）等功能。 Netfilter 是 Linux 内核中用于实现防火墙、网络地址转换 (NAT) 和包过滤的框架。相关组件iptables：最常用的用户空间工具，用于配置 Netfilter 规则。nftables：是 iptables 的继任者，提供了更强大的功能和更简洁的语法。&nbsp; iptables基础我们知道iptables是按照规则来办事的，我们就来说说规则（rules），规则其实就是网络管理员预定义的条件，规则一般的定义为”如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。配置防火墙的主要工作就是添加、修改和删除这些规则。也就是说，当我们启用了防火墙功能时，报文需要经过如下关卡，那么根据实际情况的不同，报文经过”链”可能不同。如果报文需要转发，那么报文则不会经过input链发往用户空间，而是直接在内核空间中经过forward链和postrouting链转发出去的。 所以，根据上图，我们能够想象出某些常用场景中，报文的流向：到本机某进程的报文：PREROUTING –&gt; INPUT由本机转发的报文：PREROUTING –&gt; FORWARD –&gt; POSTROUTING由本机的某进程发出报文（通常为响应报文）：OUTPUT –&gt; POSTROUTING 链的概念现在，我们想象一下，这些”关卡”在iptables中为什么被称作”链”呢？我们知道，防火墙的作用就在于对经过的报文匹配”规则”，然后执行对应的”动作”,所以，当报文经过这些关卡的时候，则必须匹配这个关卡上的规则，但是，这个关卡上可能不止有一条规则，而是有很多条规则，当我们把这些规则串到一个链条上的时候，就形成了”链”,所以，我们把每一个”关卡”想象成如下图中的模样 ，这样来说，把他们称为”链”更为合适，每个经过这个”关卡”的报文，都要将这条”链”上的所有规则匹配一遍，如果有符合条件的规则，则执行规则对应的动作。 表的概念我们再想想另外一个问题，我们对每个”链”上都放置了一串规则，但是这些规则有些很相似，比如，A类规则都是对IP或者端口的过滤，B类规则是修改报文，那么这个时候，我们是不是能把实现相同功能的规则放在一起呢，必须能的。&nbsp;&nbsp;我们把具有相同功能的规则的集合叫做”表”，所以说，不同功能的规则，我们可以放置在不同的表中进行管理，而iptables已经为我们定义了4种表，每种表对应了不同的功能，而我们定义的规则也都逃脱不了这4种功能的范围，所以，学习iptables之前，我们必须先搞明白每种表 的作用。&nbsp;iptables为我们提供了如下规则的分类，或者说，iptables为我们提供了如下”表”&nbsp;&nbsp;filter表：负责过滤功能，防火墙；内核模块：iptables_filter nat表：network address translation，网络地址转换功能；内核模块：iptable_nat mangle表：拆解报文，做出修改，并重新封装 的功能；iptable_mangle raw表：关闭nat表上启用的连接追踪机制；iptable_raw 也就是说，我们自定义的所有规则，都是这四种分类中的规则，或者说，所有规则都存在于这4张”表”中。 表和链的关系某些”链”中注定不会包含”某类规则”，就像某些”关卡”天生就不具备某些功能一样，比如，A”关卡”只负责打击陆地敌人，没有防空能力，B”关卡”只负责打击空中敌人，没有防御步兵的能力，C”关卡”可能比较NB，既能防空，也能防御陆地敌人，D”关卡”最屌，海陆空都能防。 还是以图为例，先看看prerouting”链”上的规则都存在于哪些表中。注意： 下图只用于说明prerouting链上的规则存在于哪些表中，并没有描述表的顺序。 这幅图是什么意思呢？它的意思是说，prerouting”链”只拥有nat表、raw表和mangle表所对应的功能，所以，prerouting中的规则只能存放于nat表、raw表和mangle表中。 那么，根据上述思路，我们来总结一下，每个”关卡”都拥有什么功能， 或者说，每个”链”中的规则都存在于哪些”表”中。 PREROUTING 的规则可以存在于：raw表、mangle表、nat表。 INPUT 的规则可以存在于：mangle表、filter表、nat表。 FORWARD 的规则可以存在于：mangle表、filter表。 OUTPUT 的规则可以存在于：raw表、mangle表、nat表、filter表。 POSTROUTING 的规则可以存在于：mangle表、nat表。 但是，我们在实际的使用过程中，往往是通过”表”作为操作入口，对规则进行定义的，之所以按照上述过程介绍iptables，是因为从”关卡”的角度更容易从入门的角度理解，但是为了以便在实际使用的时候，更加顺畅的理解它们，此处我们还要将各”表”与”链”的关系罗列出来，表（功能）&lt;–&gt; 链（钩子）： raw 表中的规则可以被哪些链使用：PREROUTING，OUTPUT mangle 表中的规则可以被哪些链使用：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING nat 表中的规则可以被哪些链使用：PREROUTING，INPUT，OUTPUT，POSTROUTING filter 表中的规则可以被哪些链使用：INPUT，FORWARD，OUTPUT 我们还需要注意一点，因为数据包经过一个”链”的时候，会将当前链的所有规则都匹配一遍，但是匹配时总归要有顺序，我们应该一条一条的去匹配，而且我们说过，相同功能类型的规则会汇聚在一张”表”中，那么，哪些”表”中的规则会放在”链”的最前面执行呢，这时候就需要有一个优先级的问题，我们还拿prerouting”链”做图示。 prerouting链中的规则存放于三张表中，而这三张表中的规则执行的优先级如下：raw –&gt; mangle –&gt; nat 但是我们知道，iptables为我们定义了4张”表”,当他们处于同一条”链”时，执行的优先级如下优先级次序（由高而低）： raw –&gt; mangle –&gt; nat –&gt; filter 我们前面说过，某些链天生就不能使用某些表中的规则，所以，4张表中的规则处于同一条链的目前只有output链，它就是传说中海陆空都能防守的关卡。 数据经过防火墙的流程结合上述所有的描述，我们可以将数据包通过防火墙的流程总结为下图： 我们在写Iptables规则的时候，要时刻牢记这张路由次序图，灵活配置规则。 我们将经常用到的对应关系重新写在此处，方便对应图例查看。链的规则存放于哪些表中（从链到表的对应关系）： PREROUTING 的规则可以存在于：raw表、mangle表、nat表。 INPUT 的规则可以存在于：mangle表、filter表、nat表。 FORWARD 的规则可以存在于：mangle表、filter表。 OUTPUT 的规则可以存在于：raw表、mangle表、nat表、filter表。 POSTROUTING 的规则可以存在于：mangle表、nat表。 表中的规则可以被哪些链使用（从表到链的对应关系）： raw 表中的规则可以被哪些链使用：PREROUTING，OUTPUT mangle 表中的规则可以被哪些链使用：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING nat 表中的规则可以被哪些链使用：PREROUTING，INPUT，OUTPUT，POSTROUTING filter 表中的规则可以被哪些链使用：INPUT，FORWARD，OUTPUT &nbsp; 规则的概念规则：根据指定的匹配条件来尝试匹配每个流经此处的报文，一旦匹配成功，则由规则后面指定的处理动作进行处理； 那么我们来通俗的解释一下什么是iptables的规则，之前打过一个比方，每条”链”都是一个”关卡”，每个通过这个”关卡”的报文都要匹配这个关卡上的规则，如果匹配，则对报文进行对应的处理，比如说，你我二人此刻就好像两个”报文”，你我二人此刻都要入关，可是城主有命，只有器宇轩昂的人才能入关，不符合此条件的人不能入关，于是守关将士按照城主制定的”规则”，开始打量你我二人，最终，你顺利入关了，而我已被拒之门外，因为你符合”器宇轩昂”的标准，所以把你”放行”了，而我不符合标准，所以没有被放行，其实，”器宇轩昂”就是一种”匹配条件”，”放行”就是一种”动作”，”匹配条件”与”动作”组成了规则。 规则由 匹配条件 和 处理动作 组成匹配条件匹配条件分为基本匹配条件与扩展匹配条件 基本匹配条件：源地址Source IP，目标地址 Destination IP 上述内容都可以作为基本匹配条件。 扩展匹配条件：除了上述的条件可以用于匹配，还有很多其他的条件可以用于匹配，这些条件泛称为扩展条件，这些扩展条件其实也是netfilter中的一部分，只是以模块的形式存在，如果想要使用这些条件，则需要依赖对应的扩展模块。 源端口Source Port, 目标端口Destination Port 上述内容都可以作为扩展匹配条件 处理动作一些常用的动作： ACCEPT：允许数据包通过。 DROP：直接丢弃数据包，不给任何回应信息，这时候客户端会感觉自己的请求泥牛入海了，过了超时时间才会有反应。 REJECT：拒绝数据包通过，必要时会给数据发送端一个响应的信息，客户端刚请求就会收到拒绝的信息。 SNAT：源地址转换，解决内网用户用同一个公网地址上网的问题。 MASQUERADE：是SNAT的一种特殊形式，适用于动态的、临时会变的ip上。 DNAT：目标地址转换。 REDIRECT：在本机做端口映射。 LOG：在&#x2F;var&#x2F;log&#x2F;messages文件中记录日志信息，然后将数据包传递给下一条规则，也就是说除了记录以外不对数据包做任何其他操作，仍然让下一条规则去匹配。 ★,°:.☆(￣▽￣)&#x2F;$:.°★ 。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiang07shuai06.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"iptables","slug":"iptables","permalink":"https://jiang07shuai06.github.io/tags/iptables/"}],"author":"byte76"},{"title":"HTTP基础概念","slug":"HTTP","date":"2024-12-24T02:37:22.519Z","updated":"2024-12-24T12:30:31.672Z","comments":true,"path":"2024/12/24/HTTP/","permalink":"https://jiang07shuai06.github.io/2024/12/24/HTTP/","excerpt":"","text":"HTTP超文本传输协议（HTTP）是一个用于传输超媒体文档（例如HTML）的应用层协议。它是为了Web浏览器与Web服务器之间的通信而设计的，但也可以用于其他目的（例如API通信）。HTTP是无状态协议，这意味着服务器不会在两个请求之间保留任何数据（状态）。 什么是HTTP请求？HTTP请求是客户端（比如浏览器）向服务器请求获取资源（如网页、图片、文件等）时发送的消息。包含如下几个关键部分： 请求行：包含请求方法（如 GET 用于获取资源、POST用于提交数据）、请求的 URL（统一资源定位符，指定要访问的资源位置）和 HTTP 协议版本。 请求头：包含一些额外的信息，像用户代理（表明请求的客户端类型）、接受的内容类型（如接受 HTML、JSON 等）、缓存控制信息等，用于告诉服务器更多关于请求的细节。 请求体（可选）：主要用于 POST 等请求方法，在其中放置要发送给服务器的数据，例如表单数据。 首先要明确，不是所有的 HTTP 请求方法都使用请求体。最常用于发送请求体的方法是 POST 和 PUT。 POST 方法通常用于向服务器提交数据来创建新的资源。例如，当用户在网页上填写一个注册表单并提交时，浏览器会使用 POST 方法将表单数据发送到服务器的注册接口。 PUT 方法主要用于更新服务器上已有的资源。假设一个在线文档编辑应用，用户修改了文档内容后，点击保存，应用可能会使用 PUT 方法将更新后的文档内容发送到服务器来更新文档资源。 http请求方法在 HTTP 通信过程中，每个 HTTP请求报文中都会包含一个 HTTP请求方法，用于告知客户端向服务器端请求执行某些具体的操作，下面列举几项常用的 HTTP请求方法 HTTP 请求方法 描述 GET 用于客户端请求指定资源信息，并返回指定资源实体 HEAD 和 GET 相似，但其不需要服务器响应请求的资源，而返回响应首部（只需要响应首部即可，就是告诉我有或者没有，不需要缓存界面给我） POST 基于HTML表单向服务器提交数据，服务i去通常需要存储此数据，通常存放在 MySQL 这种关系型数据库中 PUT 与 GET 相反，是向服务器发送资源的，服务器通常需要存储次资源，这就好比你要把一个新的商品送到商店并让商店存储起来。 DELETE 请求服务器端删除URL指定的资源 MOVE 请求服务器将指定的页面移至另一个网络地址 OPTIONS 探测服务器端对请求的URL所支持使用的请求方法 TRACE 跟踪一次请求中间所经历的代理服务器、防火墙或网关等。主要用于调试。 扩展：推荐一款功能强大的的 API开发和测试工具—— postman http协议版本http 0.9：最初的版本，仅支持 GET 方法，主要用于获取 HTML 文档，没有其他的概念，响应也很简单，只会返回 HTML 文档内容，没有状态码、响应头这些内容。 http 1.0：相较于0.9版本新增了多种请求方法，如 POST、HEAD等。引入了请求头和响应头，用于传递关于请求和响应的更多信息；例如，通过请求头中的 “Accept” 字段，客户端可以告诉服务器它能够接受的内容类型；响应头中的 “Content - Type” 字段则告知客户端返回内容的类型。支持多种内容类型，包括文本、图像、音频等多种格式的文件传输。 http 1.1： 目前广泛使用的版本之一，在1.0版本中，每次请求&#x2F;响应完成后，连接就会关闭。而1.1版本中允许在一次 TCP 连接中进行多次请求&#x2F;响应，减少了建立和关闭连接的开销，提高了网络传输效率。新增了更多的请求方法，如 PUT、DELETE 等。引入了管道化技术，允许客户端在等待一个请求的响应时发送下一个请求。不过，管道化在实际应用中因为一些复杂的原因（如请求顺序依赖等）没有得到广泛使用。 http 2.0：采用二进制格式进行数据传输，相比于1.1版本的文本格式，二进制格式更高效，解析速度更快。支持头部压缩，通过通过 HPB 算法压缩头部，减少传输量。多路复用是2.0版本的核心特性之一，它允许在一个 TCP 连接上同时传输多个请求和响应，这些请求和响应可以交错进行，而不需要像1.1版本那样排队等待。 什么是 HTTP 响应？HTTP 响应是服务器对客户端 HTTP 请求的回复消息。当客户端（如浏览器）向服务器发送请求，请求获取网页、文件或执行某种操作后，服务器会处理该请求，并返回一个 HTTP 响应来告知客户端请求的结果。组成部分：状态码：这是 HTTP 响应中非常关键的部分，它是一个三位数字的代码，用于表示服务器对请求的处理状态。例如，最常见的状态码 200，表示请求成功，服务器已成功处理并返回请求的资源。而 404 状态码则表示请求的资源未找到，可能是客户端请求的 URL 有误或者服务器上不存在该资源。另外还有 500 状态码，通常意味着服务器在处理请求时发生了内部错误。 响应头：响应头包含了关于响应的各种附加信息。比如 “Content - Type” 字段，它告诉客户端返回内容的类型，如 “text&#x2F;html” 表示返回的是 HTML 文档，“application&#x2F;json” 表示返回的是 JSON 格式的数据。还有 “Content - Length” 字段，用于指示响应体的长度（字节数）。此外，响应头还可能包含缓存控制信息（如 “Cache - Control”），用于指导客户端是否缓存以及如何缓存响应内容。 响应体：响应体是服务器返回的实际内容，是客户端真正需要的部分。如果客户端请求的是一个网页，那么响应体就是网页的 HTML 代码；如果请求的是一张图片，响应体就是图片的二进制数据；若请求的是一个 API 接口获取数据，响应体可能是 JSON 或 XML 格式的数据，这些数据包含了客户端所请求的信息。 http的状态码 状态码 说明 1XX 信息性状态码 2XX 成功状态码 3XX 重定向状态码 4XX 客户端错误 5XX 服务端错误 Web客户端访问Web服务器的工作流程（以网络浏览器为例）导航和启动用户在浏览器中输入网址或者点击其他通信中的链接后，浏览器通过 DNS 查找网址并将请求发送到该网址 客户端向服务器发送 HTTP 请求报文客户端（如浏览器）构建一个请求报文发送给 Web 服务器，请求报文的第一行标识了网站的根页面，指示了HTTP的版本（1.1&#x2F;1.0&#x2F;…），还有请求实体（如浏览器）的信息。请求报文发送到Web服务器后，即可由服务器读取并生成响应。 服务器将 HTTP 响应发回给客户端Web服务器收到请求后，就会生成响应报文并将其返回给浏览器（客户端），浏览器接收并读取响应报文。报文的第一行通常是响应代码如 “200 OK”，表示 Web服务器可以成功响应请求。HTTP响应报文确切再现了请求报文的格式，并包含一系列成为“响应标头”的行，这些行提供有关响应的信息。 浏览器呈现报文浏览器呈现响应报文，并在浏览器中显示网页 衡量一个 web网址的访问量指标：pv、uv、ippv：网站的点击量uv：网站的访问用户数——COOKIE，cookie值相同的表示是一个用户ip：网站的访问ip数，即有多少台客户机访问","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiang07shuai06.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"https://jiang07shuai06.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"author":"byte76"},{"title":"Hexo+Github==>个人博客","slug":"Hexo-Github-个人博客","date":"2024-10-20T08:17:35.000Z","updated":"2024-12-29T03:34:58.470Z","comments":true,"path":"2024/10/20/Hexo-Github-个人博客/","permalink":"https://jiang07shuai06.github.io/2024/10/20/Hexo-Github-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"这篇文章是对于使用 hexo 和 github 搭建个人博客的思路梳理1、下载 node.jshttps://nodejs.org/zh-cn 2、下载 githttps://git-scm.com/downloads 验证是否下载成功，管理员运行 cmd 输入以下三条命令 123node -vnpm -vgit -v 3、下载 hexo1npm install hexo-cli -g 4、搭建仓库名称格式：仓库名称.github.io 勾选 Public 勾选 Add a README file 拉到下面点击 create 创建 5、生成SSH Keys进入任意文件夹，右键空白处然后点Git bash here,输入 1ssh-keygen -t rsa -C &quot;邮件地址&quot; 然后敲4次Enter⌨️然后进入C:\\Users\\用户名，在里面进入.ssh文件用记事本打开里面的id_rsa.pub,全选复制里面的代码然后打开github进入用户设置，找到SSH keys新建SSH keys，名称随意，在下面粘贴代码，然后创建测试是否成功在git bash中输入 1ssh -T git@github.com 回车，然后再输入 yes 6、本地部署在喜欢位置新建文件Blog，然后进入文件夹右键空白处然后点 Git bash here，输入 1hexo init 然后依次输入 12hexo g # 生成hexo s # 预览 （如果不成功的话就重复直到成功，因为国内与github连接不稳定）现在就可以复制生成的链接进入浏览器看到我们生成的本地服务器了然后回到命令行，ctrl+c 关闭 7、上线博客进入之前的Blog文件夹，用记事本打开_config.yml编辑 url 段落 123# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://Jiang07Shuai06.github.io 拉到最下面将deploy后面的全删掉，复制粘贴这段 123type: gitrepository: branch: main 注意缩进格式：每行前面都有两个空格不要删，每个冒号后面都有个空格也不要删！去 github 之前生成的仓库页面，点 code，复制 https链接将其粘贴到我们记事本中的 repository：后面然后保存退出回到博客文件夹，git bash安装自动部署发布工具 1npm install hexo-deployer-git --save 然后在Blog文件夹右键打开git bash，依次输入 12hexo g # 生成hexo d # 上传 如果是第一次使用git的话会需要配置git config --global user.email &quot;你的邮箱&quot;git config --global user.name &quot;你的名字&quot;配置完后再 hexo d 上传在跳出来的窗口内进行登录接下来我们就成功把本地内容上传到github了上传成功以后，我们就算搭建好了！上自己的网址看看吧网址是我们之前设的仓库名：用户名.github.io 文章参考🔗：https://blog.fiveth.cc/p/bb32/#%E5%87%86%E5%A4%87%E5%B7%A5%E5%85%B7","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiang07shuai06.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://jiang07shuai06.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"天气预报自动推送","slug":"天气预报推送","date":"2024-10-07T09:29:17.000Z","updated":"2024-10-26T02:34:44.175Z","comments":true,"path":"2024/10/07/天气预报推送/","permalink":"https://jiang07shuai06.github.io/2024/10/07/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E6%8E%A8%E9%80%81/","excerpt":"","text":"一、申请微信测试公众号（https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login） 获取到这四个值 appID, appSecret, openId, template_id 想让谁收消息，谁就用微信扫二维码，刷新页面后即出现在用户列表，获取微信号（openId） 新增测试模板获得 template_id（模板ID） 天气模板： 123456今天：&#123;&#123;date.DATA&#125;&#125;地区：&#123;&#123;region.DATA&#125;&#125;天气：&#123;&#123;weather.DATA&#125;&#125;气温：&#123;&#123;temp.DATA&#125;&#125;风向：&#123;&#123;wind_dir.DATA&#125;&#125;对你说的话：&#123;&#123;today_note.DATA&#125;&#125; 课程表模板： 1消息：&#123;&#123;message.DATA&#125;&#125; 二、配置代码 将上面获得的几个值填入代码这几行，启动即可 12345678appID = &quot;&quot;appSecret = &quot;&quot;#收信人ID即 用户列表中的微信号，见上文openId = &quot;&quot;# 天气预报模板IDweather_template_id = &quot;&quot;# 时间表模板IDtimetable_template_id = &quot;&quot; 定时任务（根据需求进行修改这几行） 12345schedule.every().day.at(&quot;08:00&quot;).do(weather_report, &quot;北京&quot;)# schedule.every().monday.at(&quot;13:30&quot;).do(timetable, &quot;还有15分钟开始下午的课程&quot;)while True: schedule.run_pending() time.sleep(1) 完成代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166# 安装依赖 pip3 install requests html5lib bs4 scheduleimport timeimport requestsimport jsonimport schedulefrom bs4 import BeautifulSoup# 从测试号信息获取appID = &quot;wx1c904b832908e3d7&quot;appSecret = &quot;024e7a99b9bd93e4ec2ba0e61cb99869&quot;#收信人ID即 用户列表中的微信号，见上文openId = &quot;oLg156sEhzpHX3f6OKG6HaCTid9s&quot;# 天气预报模板IDweather_template_id = &quot;T00eYDomN3GOBXOTqTYhX27Nqp-vCdDO2xHKAK1ElH8&quot;# 时间表模板IDtimetable_template_id = &quot;kg29LwRP6--uo6Xq3mm-aRyJFaF_Pe2SsnUjYq23YpA&quot;def get_weather(my_city): urls = [&quot;http://www.weather.com.cn/textFC/hb.shtml&quot;, &quot;http://www.weather.com.cn/textFC/db.shtml&quot;, &quot;http://www.weather.com.cn/textFC/hd.shtml&quot;, &quot;http://www.weather.com.cn/textFC/hz.shtml&quot;, &quot;http://www.weather.com.cn/textFC/hn.shtml&quot;, &quot;http://www.weather.com.cn/textFC/xb.shtml&quot;, &quot;http://www.weather.com.cn/textFC/xn.shtml&quot; ] for url in urls: resp = requests.get(url) text = resp.content.decode(&quot;utf-8&quot;) soup = BeautifulSoup(text, &#x27;html5lib&#x27;) div_conMidtab = soup.find(&quot;div&quot;, class_=&quot;conMidtab&quot;) tables = div_conMidtab.find_all(&quot;table&quot;) for table in tables: trs = table.find_all(&quot;tr&quot;)[2:] for index, tr in enumerate(trs): tds = tr.find_all(&quot;td&quot;) # 这里倒着数，因为每个省会的td结构跟其他不一样 city_td = tds[-8] this_city = list(city_td.stripped_strings)[0] if this_city == my_city: high_temp_td = tds[-5] low_temp_td = tds[-2] weather_type_day_td = tds[-7] weather_type_night_td = tds[-4] wind_td_day = tds[-6] wind_td_day_night = tds[-3] high_temp = list(high_temp_td.stripped_strings)[0] low_temp = list(low_temp_td.stripped_strings)[0] weather_typ_day = list(weather_type_day_td.stripped_strings)[0] weather_type_night = list(weather_type_night_td.stripped_strings)[0] wind_day = list(wind_td_day.stripped_strings)[0] + list(wind_td_day.stripped_strings)[1] wind_night = list(wind_td_day_night.stripped_strings)[0] + list(wind_td_day_night.stripped_strings)[1] # 如果没有白天的数据就使用夜间的 temp = f&quot;&#123;low_temp&#125;——&#123;high_temp&#125;摄氏度&quot; if high_temp != &quot;-&quot; else f&quot;&#123;low_temp&#125;摄氏度&quot; weather_typ = weather_typ_day if weather_typ_day != &quot;-&quot; else weather_type_night wind = f&quot;&#123;wind_day&#125;&quot; if wind_day != &quot;--&quot; else f&quot;&#123;wind_night&#125;&quot; return this_city, temp, weather_typ, winddef get_access_token(): # 获取access token的url url = &#x27;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&#123;&#125;&amp;secret=&#123;&#125;&#x27; \\ .format(appID.strip(), appSecret.strip()) response = requests.get(url).json() print(response) access_token = response.get(&#x27;access_token&#x27;) return access_tokendef get_daily_love(): # 每日一句情话 url = &quot;https://api.lovelive.tools/api/SweetNothings/Serialization/Json&quot; r = requests.get(url) all_dict = json.loads(r.text) sentence = all_dict[&#x27;returnObj&#x27;][0] daily_love = sentence return daily_lovedef send_weather(access_token, weather): # touser 就是 openID # template_id 就是模板ID # url 就是点击模板跳转的url # data就按这种格式写，time和text就是之前&#123;&#123;time.DATA&#125;&#125;中的那个time，value就是你要替换DATA的值 import datetime today = datetime.date.today() today_str = today.strftime(&quot;%Y年%m月%d日&quot;) body = &#123; &quot;touser&quot;: openId.strip(), &quot;template_id&quot;: weather_template_id.strip(), &quot;url&quot;: &quot;https://weixin.qq.com&quot;, &quot;data&quot;: &#123; &quot;date&quot;: &#123; &quot;value&quot;: today_str &#125;, &quot;region&quot;: &#123; &quot;value&quot;: weather[0] &#125;, &quot;weather&quot;: &#123; &quot;value&quot;: weather[2] &#125;, &quot;temp&quot;: &#123; &quot;value&quot;: weather[1] &#125;, &quot;wind_dir&quot;: &#123; &quot;value&quot;: weather[3] &#125;, &quot;today_note&quot;: &#123; &quot;value&quot;: get_daily_love() &#125; &#125; &#125; url = &#x27;https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=&#123;&#125;&#x27;.format(access_token) print(requests.post(url, json.dumps(body)).text)def send_timetable(access_token, message): body = &#123; &quot;touser&quot;: openId, &quot;template_id&quot;: timetable_template_id.strip(), &quot;url&quot;: &quot;https://weixin.qq.com&quot;, &quot;data&quot;: &#123; &quot;message&quot;: &#123; &quot;value&quot;: message &#125;, &#125; &#125; url = &#x27;https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=&#123;&#125;&#x27;.format(access_token) print(requests.post(url, json.dumps(body)).text)def weather_report(city): # 1.获取access_token access_token = get_access_token() # 2. 获取天气 weather = get_weather(city) print(f&quot;天气信息： &#123;weather&#125;&quot;) # 3. 发送消息 send_weather(access_token, weather)def timetable(message): # 1.获取access_token access_token = get_access_token() # 3. 发送消息 send_timetable(access_token, message)if __name__ == &#x27;__main__&#x27;: weather_report(&quot;河北&quot;) # timetable(&quot;第二教学楼十分钟后开始英语课&quot;) # schedule.every().day.at(&quot;08:00&quot;).do(weather_report, &quot;北京&quot;) # schedule.every().monday.at(&quot;13:30&quot;).do(timetable, &quot;还有15分钟开始下午的课程&quot;) #while True: # schedule.run_pending() # time.sleep(1) 原创文档链接：https://www.bilibili.com/read/cv28928153/ 原创视频链接：https://www.bilibili.com/video/BV1Ng4y1r7EP/?spm_id_from=333.880.my_history.page.click&amp;vd_source=576ff0210b33e8823a0a538d3f79f11f","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiang07shuai06.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://jiang07shuai06.github.io/tags/Python/"}]},{"title":"外星人入侵","slug":"外星人入侵","date":"2024-10-04T11:05:33.000Z","updated":"2024-10-26T02:30:49.441Z","comments":true,"path":"2024/10/04/外星人入侵/","permalink":"https://jiang07shuai06.github.io/2024/10/04/%E5%A4%96%E6%98%9F%E4%BA%BA%E5%85%A5%E4%BE%B5/","excerpt":"","text":"遇到的问题及注意事项： 编写计分模块 scoreborad.py 时，变量引用错误，没搞清楚使用的是值传递还是引用传递 参考链接 https://blog.csdn.net/hohaizx/article/details/78427406 飞船数量与设置模块 settings.py 中的飞船设置相关 外星人、子弹、飞船移动速度以及幅度与设置模块 settings.py 中的 initialize_dynamic_settings 函数设置相关 参考资料及源码： 参考书籍《Python编程——从入门到实践》 参考教程链接 https://www.modb.pro/db/49581 通过百度网盘分享的文件：alien_invasion_2.0.zip 链接：https://pan.baidu.com/s/1NTkG7Mk_5sw4uzQLVU8ieQ?pwd=byte 提取码：byte","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiang07shuai06.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://jiang07shuai06.github.io/tags/Python/"}]}],"categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiang07shuai06.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"堡垒机","slug":"堡垒机","permalink":"https://jiang07shuai06.github.io/tags/%E5%A0%A1%E5%9E%92%E6%9C%BA/"},{"name":"iptables","slug":"iptables","permalink":"https://jiang07shuai06.github.io/tags/iptables/"},{"name":"网络协议","slug":"网络协议","permalink":"https://jiang07shuai06.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"博客","slug":"博客","permalink":"https://jiang07shuai06.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Python","slug":"Python","permalink":"https://jiang07shuai06.github.io/tags/Python/"}]}