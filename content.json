{"meta":{"title":"阿帅","subtitle":"","description":"这是一个关于技术分享、生活感悟和创意灵感的博客。","author":"byte76","url":"https://Jiang07Shuai06.github.io","root":"/"},"pages":[{"title":"分类","date":"2024-12-22T02:45:03.000Z","updated":"2024-12-22T02:46:40.212Z","comments":true,"path":"categories/index.html","permalink":"https://jiang07shuai06.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2025-05-14T14:53:19.301Z","updated":"2025-05-14T14:53:19.301Z","comments":true,"path":"about/index.html","permalink":"https://jiang07shuai06.github.io/about/index.html","excerpt":"","text":"哈喽，🫡 我是76，🦀 常驻地在北京，🏠 04年 “上线” 的真人“程序” 🙌"},{"title":"友情链接","date":"2020-05-13T06:16:07.000Z","updated":"2024-12-22T03:13:56.308Z","comments":true,"path":"links/index.html","permalink":"https://jiang07shuai06.github.io/links/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2024-10-11T11:48:27.035Z","updated":"2024-09-20T04:38:41.238Z","comments":true,"path":"friends/index.html","permalink":"https://jiang07shuai06.github.io/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"标签","date":"2024-12-22T03:45:14.000Z","updated":"2024-12-22T03:21:46.428Z","comments":true,"path":"tags/index.html","permalink":"https://jiang07shuai06.github.io/tags/index.html","excerpt":"","text":""},{"title":"相册","date":"2023-05-14T03:45:14.000Z","updated":"2024-12-22T03:26:00.812Z","comments":true,"path":"masonry/index.html","permalink":"https://jiang07shuai06.github.io/masonry/index.html","excerpt":"","text":""}],"posts":[{"title":"数字签名","slug":"数字签名","date":"2025-05-22T04:44:06.000Z","updated":"2025-05-22T02:40:59.666Z","comments":true,"path":"2025/05/22/数字签名/","permalink":"https://jiang07shuai06.github.io/2025/05/22/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/","excerpt":"","text":"数字签名思考 使用混合加密（前文），我们可以防止传输的消息被窃听如何确定传输的消息没有被篡改过，又如何确定是对方发送的呢？这个时候就要使用–数字签名🌶 工作原理 首先，签名者会使用散列算法(如SHA-256、SHA-3、MD5等)对原始文件内容进行计算，得到一个固定长度的数据摘要(即散列值&#x2F;哈希值) 然后，签名者使用自己的私钥对这个散列值进行加密，生成数字签名 验证者收到文件和数字签名后，使用签名者的公钥解密数字签名，得到原始散列值 验证者同时用相同的散列算法计算收到文件的散列值，并与解密得到的散列值比对 如果两个散列值完全相同，则验证通过，证明文件未被篡改且确实由持有私钥的签名者签名![数字签名](https://byte76-1325194493.cos.ap-beijing.myqcloud.com/test/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png &#x3D;865x) 结论 比对一致则表明消息是对方发过来的，也没有被篡改过 接收端使用发送端公钥能解密签名，表明收到的就是发送端的消息 散列值一致则保证了消息没有被篡改过","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiang07shuai06.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"云上安全","slug":"云上安全","permalink":"https://jiang07shuai06.github.io/tags/%E4%BA%91%E4%B8%8A%E5%AE%89%E5%85%A8/"}]},{"title":"对称秘钥和非对称秘钥","slug":"对称和非对称加密","date":"2025-05-22T02:22:07.000Z","updated":"2025-05-22T02:40:23.625Z","comments":true,"path":"2025/05/22/对称和非对称加密/","permalink":"https://jiang07shuai06.github.io/2025/05/22/%E5%AF%B9%E7%A7%B0%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86/","excerpt":"","text":"对称加密和非对称加密对称加密对称加密使用同一个秘钥来进行加密和解密对称加密算法有：RC4、DES、3DES、AES 等加密算法根据同一个秘钥将明文加密成密文，或将密文解密成明文 问题来了对称秘钥如果明文传输，可以被第三方拿到，使得第三方也可以解密密文对称秘钥如果密文传输，接收端如何解密秘钥 ![](https://byte76-1325194493.cos.ap-beijing.myqcloud.com/test/%E5%AF%B9%E7%A7%B0%E7%A7%98%E9%92%A5.png &#x3D;666x) 非对称加密非对称加密使用公钥和私钥两种秘钥，它们并不是同一个秘钥公钥用来加密明文，私钥用来解密密文公钥一般是公开的，都能拿到，私钥只有接收端才有，不公开非对称加密算法有：RSA、DH 等 非对称加密的加解密速度比对称加密要慢很多 工作原理：发送端使用公钥加密，接收端使用私钥解密；公钥和私钥由接收端生成，公钥明文传输给发送端，发送端收到后使用公钥将数据加密后发送到接收端，接收端使用私钥解密，公钥被第三方截获也没关系，因为第三方没有私钥 ![非对称秘钥](https://byte76-1325194493.cos.ap-beijing.myqcloud.com/test/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E7%A7%98%E9%92%A5.png &#x3D;502x) 混合加密对称加密不能安全的传输密钥，但是加解密速度块非对陈加密可以安全的传输密钥，但是加解密速度慢🤔🤔使用非对称加密解决对称秘钥的传输问题，使用对称加密传输数据 SSL&#x2F;TLS 使用的就是混合加密 ![混合加密](https://byte76-1325194493.cos.ap-beijing.myqcloud.com/test/%E6%B7%B7%E5%90%88%E5%8A%A0%E5%AF%86.png &#x3D;654x)","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiang07shuai06.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"云上安全","slug":"云上安全","permalink":"https://jiang07shuai06.github.io/tags/%E4%BA%91%E4%B8%8A%E5%AE%89%E5%85%A8/"}]},{"title":"Redis的三种模式解析","slug":"Redis的三种模式解析","date":"2025-05-14T14:44:12.000Z","updated":"2025-05-15T08:37:18.850Z","comments":true,"path":"2025/05/14/Redis的三种模式解析/","permalink":"https://jiang07shuai06.github.io/2025/05/14/Redis%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F%E8%A7%A3%E6%9E%90/","excerpt":"","text":"主从复制工作原理： slave启动后，向master发送SYNC命令，master接收到SYNC命令后通过bgsave保存快照（即上文所介绍的RDB持久化），并使用缓冲区记录保存快照这段时间内执行的写命令 master将保存的快照文件发送给slave，并继续记录执行的写命令 slave接收到快照文件后，加载快照文件，载入数据 master快照发送完后开始向slave发送缓冲区的写命令，slave接收命令并执行，完成复制初始化 此后master每次执行一个写命令都会同步发送给slave，保持master与slave之间数据的一致性 图1-主从复制 优点： master能自动将数据同步到slave，可以进行读写分离，分担master的读压力 master、slave之间的同步是以非阻塞的方式进行的，同步期间，客户端仍然可以提交查询或更新请求 缺点： 不具备自动容错与恢复功能，master或slave的宕机都可能导致客户端请求失败，需要等待机器重启或手动切换客户端IP才能恢复 master宕机，如果宕机前数据没有同步完，则切换IP后会存在数据不一致的问题 难以支持在线扩容，Redis的容量受限于单机配置 Sentinel（哨兵）哨兵模式基于主从复制模式，只是引入了哨兵来监控与自动处理故障。 功能主要包括： 1、监控master、slave是否正常运行 2、当master出现故障时，能自动将一个slave转换为master（大哥挂了，选一个小弟上位） 3、多个哨兵可以监控同一个Redis，哨兵之间也会自动监控 图2-哨兵模式 工作原理： 哨兵模式的具体工作机制： 在配置文件中通过 sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt; 来定位master的IP、端口，一个哨兵可以监控多个master数据库，只需要提供多个该配置项即可。哨兵启动后，会与要监控的master建立两条连接： 一条连接用来订阅master的_sentinel_:hello频道与获取其他监控该master的哨兵节点信息 另一条连接定期向master发送INFO等命令获取master本身的信息 与master建立连接后，哨兵会执行三个操作： 定期（一般10s一次，当master被标记为主观下线时，改为1s一次）向master和slave发送INFO命令 定期向master和slave的_sentinel_:hello频道发送自己的信息 定期（1s一次）向master、slave和其他哨兵发送PING命令 发送INFO命令可以获取当前数据库的相关信息从而实现新节点的自动发现。所以说哨兵只需要配置master数据库信息就可以自动发现其slave信息。获取到slave信息后，哨兵也会与slave建立两条连接执行监控。通过INFO命令，哨兵可以获取主从数据库的最新信息，并进行相应的操作，比如角色变更等。 接下来哨兵向主从数据库的_sentinel_:hello频道发送信息与同样监控这些数据库的哨兵共享自己的信息，发送内容为哨兵的ip端口、运行id、配置版本、master名字、master的ip端口还有master的配置版本。这些信息有以下用处： 其他哨兵可以通过该信息判断发送者是否是新发现的哨兵，如果是的话会创建一个到该哨兵的连接用于发送PING命令。 其他哨兵通过该信息可以判断master的版本，如果该版本高于直接记录的版本，将会更新 当实现了自动发现slave和其他哨兵节点后，哨兵就可以通过定期发送PING命令定时监控这些数据库和节点有没有停止服务。 如果被PING的数据库或者节点超时（通过 sentinel down-after-milliseconds master-name milliseconds 配置）未回复，哨兵认为其主观下线（sdown，s就是Subjectively —— 主观地）。如果下线的是master，哨兵会向其它哨兵发送命令询问它们是否也认为该master主观下线，如果达到一定数目（即配置文件中的quorum）投票，哨兵会认为该master已经客观下线（odown，o就是Objectively —— 客观地），并选举领头的哨兵节点对主从系统发起故障恢复。若没有足够的sentinel进程同意master下线，master的客观下线状态会被移除，若master重新向sentinel进程发送的PING命令返回有效回复，master的主观下线状态就会被移除 图3 哨兵认为master客观下线后，故障恢复的操作需要由选举的领头哨兵来执行，选举采用Raft算法： 发现master下线的哨兵节点（我们称他为A）向每个哨兵发送命令，要求对方选自己为领头哨兵 如果目标哨兵节点没有选过其他人，则会同意选举A为领头哨兵 如果有超过一半的哨兵同意选举A为领头，则A当选 如果有多个哨兵节点同时参选领头，此时有可能存在一轮投票无竞选者胜出，此时每个参选的节点等待一个随机时间后再次发起参选请求，进行下一轮投票竞选，直至选举出领头哨兵 选出领头哨兵后，领头者开始对系统进行故障恢复，从出现故障的master的从数据库中挑选一个来当选新的master,选择规则如下： 所有在线的slave中选择优先级最高的，优先级可以通过slave-priority配置 如果有多个最高优先级的slave，则选取复制偏移量最大（即复制越完整）的当选 如果以上条件都一样，选取id最小的slave 挑选出需要继任的slave后，领头哨兵向该数据库发送命令使其成为master，然后再向其他slave发送命令接受新的master，最后更新数据。将已经停止的旧的master更新为新的master的从数据库，使其恢复服务后以slave的身份继续运行。 优点： 哨兵模式基于主从复制模式，所以主从复制模式有的优点，哨兵模式也有 哨兵模式下，master挂掉可以自动进行切换，系统可用性更高 缺点： 同样也继承了主从模式难以在线扩容的缺点，Redis的容量受限于单机配置 需要额外的资源来启动sentinel进程，实现相对复杂一点，同时slave节点作为备份节点不提供服务 Cluster集群哨兵模式解决了主从复制不能自动故障转移，达不到高可用的问题，但还是存在难以在线扩容，Redis容量受限于单机配置的问题。Cluster模式实现了Redis的分布式存储，即每台节点存储不同的内容，来解决在线扩容的问题。 图4-集群模式 工作原理： 在Redis的每个节点上，都有一个插槽（slot），取值范围为0-16383 当我们存取key的时候，Redis会根据CRC16的算法得出一个结果，然后把结果对16384求余数，这样每个key都会对应一个编号在0-16383之间的哈希槽，通过这个值，去找到对应的插槽所对应的节点，然后直接自动跳转到这个对应的节点上进行存取操作 为了保证高可用，Cluster模式也引入主从复制模式，一个主节点对应一个或者多个从节点，当主节点宕机的时候，就会启用从节点 当其它主节点ping一个主节点A时，如果半数以上的主节点与A通信超时，那么认为主节点A宕机了。如果主节点A和它的从节点都宕机了，那么该集群就无法再提供服务了 Cluster模式集群节点最小配置6个节点(3主3从，因为需要半数以上)，其中主节点提供读写操作，从节点作为备用节点，不提供请求，只作为故障转移使用 优点： 无中心架构，数据按照slot分布在多个节点。 集群中的每个节点都是平等的关系，每个节点都保存各自的数据和整个集群的状态。每个节点都和其他所有节点连接，而且这些连接保持活跃，这样就保证了我们只需要连接集群中的任意一个节点，就可以获取到其他节点的数据。 可线性扩展到1000多个节点，节点可动态添加或删除 能够实现自动故障转移，节点之间通过gossip协议交换状态信息，用投票机制完成slave到master的角色转换 缺点： 客户端实现复杂，驱动要求实现Smart Client，缓存slots mapping信息并及时更新，提高了开发难度。目前仅JedisCluster相对成熟，异常处理还不完善，比如常见的“max redirect exception” 节点会因为某些原因发生阻塞（阻塞时间大于 cluster-node-timeout）被判断下线，这种failover是没有必要的 3. 数据通过异步复制，不保证数据的强一致性 slave充当“冷备”，不能缓解读压力 批量操作限制，目前只支持具有相同slot值的key执行批量操作，对mset、mget、sunion等操作支持不友好 key事务操作支持有线，只支持多key在同一节点的事务操作，多key分布不同节点时无法使用事务功能 不支持多数据库空间，单机redis可以支持16个db，集群模式下只能使用一个，即db 0 Redis Cluster模式不建议使用pipeline和multi-keys操作，减少max redirect产生的场景。 总结本文介绍了Redis集群方案的三种模式，其中主从复制模式能实现读写分离，但是不能自动故障转移；哨兵模式基于主从复制模式，能实现自动故障转移，达到高可用，但与主从复制模式一样，不能在线扩容，容量受限于单机的配置；Cluster模式通过无中心化架构，实现分布式存储，可进行线性扩展，也能高可用，但对于像批量操作、事务操作等的支持性不够好。三种模式各有优缺点，可根据实际场景进行选择。 注：发现问题请联系我进行订正，感谢🌹🌹","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiang07shuai06.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://jiang07shuai06.github.io/tags/Redis/"}]},{"title":"MySQL的三种安装方式示例（包成功😋）","slug":"MySQL的三种安装方式","date":"2025-05-14T14:36:06.000Z","updated":"2025-05-14T14:38:16.610Z","comments":true,"path":"2025/05/14/MySQL的三种安装方式/","permalink":"https://jiang07shuai06.github.io/2025/05/14/MySQL%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F/","excerpt":"","text":"概述定义和历史背景 MySQL 是一个广泛使用的开源关系型数据库管理系统（RDBMS）。它最初由瑞典 MySQL AB 公司开发，在 2008 年被 Sun Microsystems 收购，之后 Oracle 又收购了 Sun Microsystems，MySQL 也随之成为 Oracle 旗下的产品。 数据库存储结构数据库（Database）：MySQL 是数据库的集合，每个数据库用于存储相关的数据。 表（Table）：数据库包含一个或多个表，表是数据存储的基本单位。表由行（Row）和列（Column）组成。 索引（Index）：索引是一种特殊的数据结构，用于提高数据库的查询性能。它类似于书籍的目录，通过创建 索引，可以更快地定位和检索表中的数据。 SQL语言支持 数据定义语言（DDL）：用于定义数据库的结构，包括创建（CREATE）、修改（ALTER）和删除（DROR）数据库、表、索引等。 数据操作语言（DML）：用于操作表中的数据，主要包括插入（INSERT）、查询（SELECT）、更新（UPDATE）和删除（DELETE）操作。 数据控制语言（DCL）：主要用于管理数据库用户的权限，如GRANT（授予权限）和REVOKE（收回权限） MySQL逻辑结构与Linux系统对比: MySQL Linux 库 目录 show databases; ls -l &#x2F; use mysql cd &#x2F;mysql 表 普通文件 show tables ls 安装方式（这里使用机器为 Rocky Linux 9.4 ） 二进制安装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394## 从官方选择对应的 mysql 源码包# https://dev.mysql.com/downloads/mysql/mysql-8.4.3-linux-glibc2.28-x86_64.tar.xz# 上传下载好的压缩包到指定服务器 wget https://dev.mysql.com/get/Downloads/mysql/mysql-8.4.3-linux-glibc2.28-x86_64.tar.xztar -xvf mysql-8.4.3-linux-glibc2.28-x86_64.tar.xz mv mysql-8.4.3-linux-glibc2.28-x86_64 /usr/local/mysql## 创建mysql用户，因为启动mysql需要该用户groupadd mysqluseradd -r -g mysql -s /bin/false mysql -M ## 创建数据目录mkdir -p /data/mysqlchown -R mysql:mysql /data/mysqlchmod -R 750 /data/mysql## 初始化/usr/local/mysql/bin/mysqld --initialize-insecure --basedir=/usr/local/mysql --datadir=/data/mysql --user=mysql## 以服务的方式启动（传统方式，可选）# cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysql.server# systemctl daemon-reload# /etc/init.d/mysql.server start## 添加环境变量echo &#x27;export PATH=$PATH:/usr/local/mysql/bin&#x27; &gt;&gt; /etc/profilesource /etc/profile################################################################### 将传统的以服务启动的方式改为 systemd 进行管理## 首先关闭 selinux ！！！## 在/etc/systemd/system/目录下配置文件 mysql.servicecat &gt; /etc/systemd/system/mysql.service &lt;&lt; EOF[Unit]Description=MySQL ServerAfter=network.target syslog.target[Service]User=mysqlGroup=mysqlExecStart=/usr/local/mysql/bin/mysqld --defaults-file=/etc/my.cnfExecReload=/bin/kill -HUP $MAINPIDRestart=on-failure[Install]WantedBy=multi-user.target EOF## 配置默认文件缺失# MySQL 不会在二进制安装时自动生成 my.cnf 文件，因为它无法确定需要的具体配置。这就意味着你得手动创建该文件。# 在 ExecStart 行中启动命令后添加 --defaults-file=/etc/my.cnf 参数进行配置文件关联# 创建 my.cnf 文件cat &gt; /etc/my.cnf &lt;&lt; EOF[mysqld]# 基本目录basedir = /usr/local/mysql# 数据目录datadir = /data/mysql# PID文件路径pid-file = /data/mysql/mysql.pid# 套接字文件路径socket = /tmp/mysql.sock# 监听端口port = 3306# 其他常见配置# 字符集设置character-set-server = utf8mb4collation-server = utf8mb4_unicode_ci# 日志相关配置log-error = /data/mysql/error.loggeneral_log = 0general_log_file = /data/mysql/general.logslow_query_log = 1slow_query_log_file = /data/mysql/slow.loglong_query_time = 2# 内存相关配置innodb_buffer_pool_size = 128Mkey_buffer_size = 16MEOF # 赋权chmod 644 /etc/my.cnf## 启动systemctl daemon-reloadsystemctl restart mysqlsystemctl status mysql# 以下命令可查看 MySQL 所有的配置选项及其当前值SHOW VARIABLES; 从源码编译安装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149## 从官方选择对应的 mysql 源码包# https://dev.mysql.com/downloads/mysql/# 上传下载好的压缩包到指定服务器wget https://dev.mysql.com/get/Downloads/mysql/mysql-8.4.3.tar.gztar -zxvf mysql-8.4.3.tar.gzcd mysql-8.4.3mkdir buildcd build# 下载必要的软件包yum install -y gcc gcc-c++ make cmake ncurses-devel bison wget tar bzip2 zlib zlib-devel gcc-toolset-12-gcc gcc-toolset-12-gcc-c++ gcc-toolset-12-binutils gcc-toolset-12-annobin-annocheck gcc-toolset-12-annobin-plugin-gcc openssl openssl-devel sudo dnf install -y rpcgen## 安装libtirpc-develyum install -y libtirpc-devel # 这个一般不行wget https://rpmfind.net/linux/centos-stream/9-stream/BaseOS/x86_64/os/Packages/libtirpc-1.3.3-2.el9.x86_64.rpmrpm -ivh libtirpc-1.3.3-2.el9.x86_64.rpm# sudo rpm -Uvh --oldpackage libtirpc-1.3.3-2.el9.x86_64.rpm -U:有则升级，无则安装。wget https://rpmfind.net/linux/centos-stream/9-stream/CRB/x86_64/os/Packages/libtirpc-devel-1.3.3-2.el9.x86_64.rpmrpm -ivh libtirpc-devel-1.3.3-2.el9.x86_64.rpm # 依赖环境cd /rootwget https://boostorg.jfrog.io/artifactory/main/release/1.77.0/source/boost_1_77_0.tar.bz2tar -jxvf boost_1_77_0.tar.bz2# build 是个空目录cd mysql-8.4.3/build/# 到MySQL源码的build目录（个人新建）并运行cmake命令，以继续配置和编译MySQL：cmake .. -DWITH_BOOST=/root/boost_1_77_0 \\ -DWITH_ZLIB=bundled \\ -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\ -DMYSQL_DATADIR=/usr/local/mysql/data \\ -DSYSCONFDIR=/etc \\ -DWITH_INNOBASE_STORAGE_ENGINE=1 \\ -DWITH_PARTITION_STORAGE_ENGINE=1 \\ -DWITH_FEDERATED_STORAGE_ENGINE=1 \\ -DWITH_BLACKHOLE_STORAGE_ENGINE=1 \\ -DWITH_ARCHIVE_STORAGE_ENGINE=1 \\ -DENABLED_LOCAL_INFILE=1 \\ -DWITH_SSL=system \\ -DWITH_LIBWRAP=0 \\ -DMYSQL_UNIX_ADDR=/var/lib/mysql/mysql.sock # 编译 MySQLmake# 安装 MySQLmake install ## 开始配置# 创建mysql用户和配置权限# 创建一个名为 mysql 的用户组groupadd mysql# -r表示创建一个系统用户（system user），这种用户通常用于运行服务或系统进程，没有登录权限。# -g mysql：指定用户的主组为 mysql，让该用户属于前面创建的 mysql 用户组。# -s /bin/false：指定用户的默认登录 shell 为 /bin/false，这样做的目的是不允许该用户登录系统，进一步增强安全性。useradd -r -g mysql -s /bin/false mysql## /etc/my.cnfcat &gt; /etc/my.cnf &lt;&lt;EOF[mysqld] # 表示这是 MySQL 服务的配置部分basedir = /usr/local/mysql # 设置 MySQL 的安装目录为 /usr/local/mysqldatadir = /usr/local/mysql/data # 设置 MySQL 的数据存储目录为 /usr/local/mysql/dataport = 3306 # 指定 MySQL 服务监听的端口号为 3306，这是 MySQL 的默认端口socket = /var/lib/mysql/mysql.sock # 指定 MySQL 进程的 socket 文件路径，用于本地客户端连接user = mysql # 指定运行 MySQL 服务的用户为 mysql，增加安全性symbolic-links = 0 # 禁用符号链接功能，增加系统安全性log_error = /var/log/mysql/error.log # 设置错误日志文件的路径，记录 MySQL 服务的错误信息general_log = 1 # 启用通用查询日志，记录所有执行的查询语句general_log_file = /var/log/mysql/general.log # 设置通用查询日志的存储路径slow_query_log = 1 # 启用慢查询日志，用于记录执行时间较长的查询slow_query_log_file = /var/log/mysql/slow.log # 指定慢查询日志文件的路径long_query_time = 2 # 设置慢查询的阈值，记录执行时间超过 2 秒的查询# pid-file = /var/run/mysqld/mysqld.pidpid-file=/usr/local/mysql/mysqld.pid EOFmkdir -p /var/log/mysql# mkdir -p /var/run/mysqldmkdir -p /var/lib/mysql# mysql logs for /var/log/mysqlchown -R mysql:mysql /var/log/mysqlchmod -R 750 /var/log/mysql# /usr/local/mysql 安装主目录chown -R mysql:mysql /usr/local/mysqlchmod -R 750 /usr/local/mysqlmkdir /usr/local/mysql/datachown -R mysql:mysql /usr/local/mysql/datachmod -R 750 /usr/local/mysql/data# /var/run/mysqld/mysqld.pid# chown mysql:mysql /var/run/mysqld# chmod 755 /var/run/mysqld# /var/lib/mysql/mysql.sock chown -R mysql:mysql /var/lib/mysqlchmod -R 750 /var/lib/mysql## 初始化/usr/local/mysql/bin/mysqld --defaults-file=/etc/my.cnf --initialize-insecure## 启动 mysql 服务cat &gt; /etc/systemd/system/mysql.service&lt;&lt;EOF[Unit]Description=MySQL ServerAfter=network.target[Service]Type=forkingExecStart=/usr/local/mysql/bin/mysqld --defaults-file=/etc/my.cnf --daemonize --pid-file=/var/run/mysqld/mysqld.pidExecStop=/usr/local/mysql/bin/mysqladmin --defaults-file=/etc/my.cnf shutdownUser=mysqlGroup=mysqlPIDFile=/var/run/mysqld/mysqld.pid[Install]WantedBy=multi-user.targetEOFsystemctl daemon-reloadsystemctl enable mysqlsystemctl start mysql## 设置个root密码/usr/local/mysql/bin/mysql_secure_installation# Ag#@190&#125;678900 # 我的密码# 添加到系统环境变量vim /etc/profileexport PATH=$PATH:/usr/local/mysql/binsource /etc/profilemysql -uroot -pAg#@190&#125;678900 # 新建个远程管理用户# 开启远程连接CREATE USER &#x27;sxs&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;Ag#@190&#125;678900&#x27;;GRANT ALL PRIVILEGES ON *.* TO &#x27;sxs&#x27;@&#x27;%&#x27; WITH GRANT OPTION;flush privileges; yum 安装方式 1234567- 本地系统源安装 yum -y install mysql # 安装的 mysql软件包包含了 MySQL 客户端程序等组件。 ## 这使得用户能够在命令行下连接到远程 MySQL 服务器进行数据库操作，如查询数据库、执行 SQL 语句等。 yum -y install mysql-server # 安装 MySQL 服务器相关的软件包。 ## 这个命令会安装 MySQL 服务器软件，使得计算机能够作为一个 MySQL 服务器运行，接受客户端的连接请求并处理数据库事务。 12345678910111213141516171819202122232425262728- 官方源安装（脱离了系统源） ## 从官方选择对应的操作系统的 mysql 安装源 # https://dev.mysql.com/downloads/ # 上传下载好的 rpm 包到指定服务器 scp .\\mysql84-community-release-el9-1.noarch.rpm root@192.168.241.130:/root # 安装下载好的源 dnf install -y mysql84-community-release-el9-1.noarch.rpm # 安装 MySQL 服务器及其依赖项 sudo dnf install mysql-server # 启动 MySQL 服务并设置开机自启 sudo systemctl --now enable mysqld # 获取临时密码 grep &#x27;temporary password&#x27; /var/log/mysqld.log # 登录并修改密码 mysql -uroot -p # 查看安全策略（可选） SHOW VARIABLES LIKE &#x27;validate_password%&#x27;; # 降低安全策略（可选，主要是为了学习或者测试时设置简单的密码方便记忆） set global validate_password.policy=0; set global validate_password.length=1; 通过 MySQL 安装向导（适用于 Windows 环境）","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiang07shuai06.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://jiang07shuai06.github.io/tags/MySQL/"}]},{"title":"堡垒机(1) | 概念&部署","slug":"堡垒机-1-概念-部署","date":"2025-01-12T03:30:10.000Z","updated":"2025-01-12T04:31:06.481Z","comments":true,"path":"2025/01/12/堡垒机-1-概念-部署/","permalink":"https://jiang07shuai06.github.io/2025/01/12/%E5%A0%A1%E5%9E%92%E6%9C%BA-1-%E6%A6%82%E5%BF%B5-%E9%83%A8%E7%BD%B2/","excerpt":"","text":"简介堡垒机是一种用于单点登录、集中授权、访问控制和操作审计的安全设备，也被称为跳板机。它就像网络中的 “安全卫士”，主要作用是对内部网络中运维人员的操作进行集中管理和控制，是实现运维安全的核心设备。主要功能：身份认证、访问控制、操作审计、会话管理Jumpserver 是一款由python编写开源的跳板机（堡垒机）系统，实现了跳板机应有的功能。基于ssh协议来管理，客户端无需安装agent。&nbsp;在公司中，分配人员服务器权限也是相当方便，如：来一个新人，在Jumpserver分配Jumpserver账号即可，人员离职，在Jumpserver删掉人员账号即可。无需担心人员离职留下后门，当然前提是检查防火墙，只允许Jumpserver服务器有其他服务器的ssh的权限。目前市面上已经有很多jumpserver产品提供使用，这里就介绍最广泛的一款。官方网址：https://www.jumpserver.org/&nbsp; JumpServer 部署参考官方部署文档：https://docs.jumpserver.org/zh/master/install/setup_by_fast/&nbsp;这款也是基于docker运行的，不管一键部署，还是手动部署都是docker，手动部署区别主要是改密码、IP、端口自定义之类的。默认的其实已经很好没必要改了。相对来所，搭建还是比较容易的，官方脚本一步到位。&nbsp;由于魔法的原因可能会无法连接到 GitHub，这里可以考虑使用以下命令 1curl -sSL https://resource.fit2cloud.com/jumpserver/jumpserver/releases/latest/download/quick_start.sh | bash 注：4核8G （最低）且可以访问互联网的 64 位 Linux 主机 当然，如果需要离线安装也可以到下方 URI 获取软件包后，进行手动部署 https://community.fit2cloud.com/#/products/jumpserver/downloads 下面是我部署完成后显示的信息 &nbsp; 可以使用如下命令启动, 然后访问cd &#x2F;opt&#x2F;jumpserver-installer-v4.5.0.&#x2F;jmsctl.sh start 其它一些管理命令.&#x2F;jmsctl.sh stop.&#x2F;jmsctl.sh restart.&#x2F;jmsctl.sh backup.&#x2F;jmsctl.sh upgrade更多还有一些命令, 你可以 .&#x2F;jmsctl.sh –help 来了解 Web 访问http://192.168.241.66:80默认用户: admin 默认密码: ChangeMe 更多信息官方网站: https://www.jumpserver.org/官方文档: https://docs.jumpserver.org/","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiang07shuai06.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"堡垒机","slug":"堡垒机","permalink":"https://jiang07shuai06.github.io/tags/%E5%A0%A1%E5%9E%92%E6%9C%BA/"}]},{"title":"iptables(1) | iptables概念","slug":"iptables-1-iptables概念","date":"2025-01-06T03:29:01.000Z","updated":"2025-01-08T10:19:55.774Z","comments":true,"path":"2025/01/06/iptables-1-iptables概念/","permalink":"https://jiang07shuai06.github.io/2025/01/06/iptables-1-iptables%E6%A6%82%E5%BF%B5/","excerpt":"","text":"相关概念防火墙从逻辑上可以分为主机防火墙和网络防火墙 主机防火墙：针对单个主机进行防护。 网络防火墙：往往处于网络入口，针对于网络入口进行防护，服务于防火墙背后的本地局域网。 网络防火墙和主机防火墙并不冲突，可以理解为，网络防火墙主外（集体）， 主机防火墙主内（个人）。 防火墙从物理上可以分为硬件防火墙和软件防火墙 硬件防火墙：硬件防火墙是一种专门设计的网络安全设备，它基于硬件平台运行，性能高，成本高。 软件防火墙：软件防火墙是安装在计算机操作系统或网络设备操作系统中的软件程序。性能低，成本低。&nbsp; 关于iptables **iptables** 其实不是真正的防火墙，我们可以把它理解成一个客户端代理，用户通过iptables这个代理，将用户的安全设定执行到对应的”安全框架”中，这个”安全框架”才是真正的防火墙，这个框架的名字叫 **netfilter**。 netfilter 才是防火墙真正的安全框架（framework)，netfilter位于内核空间。 iptables 其实是一个命令行工具，位于用户空间，我们用这个工具操作真正的框架。 netfilter&amp;iptables 组成Linux平台下的包过滤防火墙，与大多数的Linux软件一样，这个包过滤防火墙是免费的，它可以代替昂贵的商业防火墙解决方案，完成封包过滤、封包重定向和网络地址转换（NAT）等功能。 Netfilter 是 Linux 内核中用于实现防火墙、网络地址转换 (NAT) 和包过滤的框架。相关组件iptables：最常用的用户空间工具，用于配置 Netfilter 规则。nftables：是 iptables 的继任者，提供了更强大的功能和更简洁的语法。&nbsp; iptables基础我们知道iptables是按照规则来办事的，我们就来说说规则（rules），规则其实就是网络管理员预定义的条件，规则一般的定义为”如果数据包头符合这样的条件，就这样处理这个数据包”。规则存储在内核空间的信息包过滤表中，这些规则分别指定了源地址、目的地址、传输协议（如TCP、UDP、ICMP）和服务类型（如HTTP、FTP和SMTP）等。当数据包与规则匹配时，iptables就根据规则所定义的方法来处理这些数据包，如放行（accept）、拒绝（reject）和丢弃（drop）等。配置防火墙的主要工作就是添加、修改和删除这些规则。也就是说，当我们启用了防火墙功能时，报文需要经过如下关卡，那么根据实际情况的不同，报文经过”链”可能不同。如果报文需要转发，那么报文则不会经过input链发往用户空间，而是直接在内核空间中经过forward链和postrouting链转发出去的。 所以，根据上图，我们能够想象出某些常用场景中，报文的流向：到本机某进程的报文：PREROUTING –&gt; INPUT由本机转发的报文：PREROUTING –&gt; FORWARD –&gt; POSTROUTING由本机的某进程发出报文（通常为响应报文）：OUTPUT –&gt; POSTROUTING 链的概念现在，我们想象一下，这些”关卡”在iptables中为什么被称作”链”呢？我们知道，防火墙的作用就在于对经过的报文匹配”规则”，然后执行对应的”动作”,所以，当报文经过这些关卡的时候，则必须匹配这个关卡上的规则，但是，这个关卡上可能不止有一条规则，而是有很多条规则，当我们把这些规则串到一个链条上的时候，就形成了”链”,所以，我们把每一个”关卡”想象成如下图中的模样 ，这样来说，把他们称为”链”更为合适，每个经过这个”关卡”的报文，都要将这条”链”上的所有规则匹配一遍，如果有符合条件的规则，则执行规则对应的动作。 表的概念我们再想想另外一个问题，我们对每个”链”上都放置了一串规则，但是这些规则有些很相似，比如，A类规则都是对IP或者端口的过滤，B类规则是修改报文，那么这个时候，我们是不是能把实现相同功能的规则放在一起呢，必须能的。&nbsp;&nbsp;我们把具有相同功能的规则的集合叫做”表”，所以说，不同功能的规则，我们可以放置在不同的表中进行管理，而iptables已经为我们定义了4种表，每种表对应了不同的功能，而我们定义的规则也都逃脱不了这4种功能的范围，所以，学习iptables之前，我们必须先搞明白每种表 的作用。&nbsp;iptables为我们提供了如下规则的分类，或者说，iptables为我们提供了如下”表”&nbsp;&nbsp;filter表：负责过滤功能，防火墙；内核模块：iptables_filter nat表：network address translation，网络地址转换功能；内核模块：iptable_nat mangle表：拆解报文，做出修改，并重新封装 的功能；iptable_mangle raw表：关闭nat表上启用的连接追踪机制；iptable_raw 也就是说，我们自定义的所有规则，都是这四种分类中的规则，或者说，所有规则都存在于这4张”表”中。 表和链的关系某些”链”中注定不会包含”某类规则”，就像某些”关卡”天生就不具备某些功能一样，比如，A”关卡”只负责打击陆地敌人，没有防空能力，B”关卡”只负责打击空中敌人，没有防御步兵的能力，C”关卡”可能比较NB，既能防空，也能防御陆地敌人，D”关卡”最屌，海陆空都能防。 还是以图为例，先看看prerouting”链”上的规则都存在于哪些表中。注意： 下图只用于说明prerouting链上的规则存在于哪些表中，并没有描述表的顺序。 这幅图是什么意思呢？它的意思是说，prerouting”链”只拥有nat表、raw表和mangle表所对应的功能，所以，prerouting中的规则只能存放于nat表、raw表和mangle表中。 那么，根据上述思路，我们来总结一下，每个”关卡”都拥有什么功能， 或者说，每个”链”中的规则都存在于哪些”表”中。 PREROUTING 的规则可以存在于：raw表、mangle表、nat表。 INPUT 的规则可以存在于：mangle表、filter表、nat表。 FORWARD 的规则可以存在于：mangle表、filter表。 OUTPUT 的规则可以存在于：raw表、mangle表、nat表、filter表。 POSTROUTING 的规则可以存在于：mangle表、nat表。 但是，我们在实际的使用过程中，往往是通过”表”作为操作入口，对规则进行定义的，之所以按照上述过程介绍iptables，是因为从”关卡”的角度更容易从入门的角度理解，但是为了以便在实际使用的时候，更加顺畅的理解它们，此处我们还要将各”表”与”链”的关系罗列出来，表（功能）&lt;–&gt; 链（钩子）： raw 表中的规则可以被哪些链使用：PREROUTING，OUTPUT mangle 表中的规则可以被哪些链使用：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING nat 表中的规则可以被哪些链使用：PREROUTING，INPUT，OUTPUT，POSTROUTING filter 表中的规则可以被哪些链使用：INPUT，FORWARD，OUTPUT 我们还需要注意一点，因为数据包经过一个”链”的时候，会将当前链的所有规则都匹配一遍，但是匹配时总归要有顺序，我们应该一条一条的去匹配，而且我们说过，相同功能类型的规则会汇聚在一张”表”中，那么，哪些”表”中的规则会放在”链”的最前面执行呢，这时候就需要有一个优先级的问题，我们还拿prerouting”链”做图示。 prerouting链中的规则存放于三张表中，而这三张表中的规则执行的优先级如下：raw –&gt; mangle –&gt; nat 但是我们知道，iptables为我们定义了4张”表”,当他们处于同一条”链”时，执行的优先级如下优先级次序（由高而低）： raw –&gt; mangle –&gt; nat –&gt; filter 我们前面说过，某些链天生就不能使用某些表中的规则，所以，4张表中的规则处于同一条链的目前只有output链，它就是传说中海陆空都能防守的关卡。 数据经过防火墙的流程结合上述所有的描述，我们可以将数据包通过防火墙的流程总结为下图： 我们在写Iptables规则的时候，要时刻牢记这张路由次序图，灵活配置规则。 我们将经常用到的对应关系重新写在此处，方便对应图例查看。链的规则存放于哪些表中（从链到表的对应关系）： PREROUTING 的规则可以存在于：raw表、mangle表、nat表。 INPUT 的规则可以存在于：mangle表、filter表、nat表。 FORWARD 的规则可以存在于：mangle表、filter表。 OUTPUT 的规则可以存在于：raw表、mangle表、nat表、filter表。 POSTROUTING 的规则可以存在于：mangle表、nat表。 表中的规则可以被哪些链使用（从表到链的对应关系）： raw 表中的规则可以被哪些链使用：PREROUTING，OUTPUT mangle 表中的规则可以被哪些链使用：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING nat 表中的规则可以被哪些链使用：PREROUTING，INPUT，OUTPUT，POSTROUTING filter 表中的规则可以被哪些链使用：INPUT，FORWARD，OUTPUT &nbsp; 规则的概念规则：根据指定的匹配条件来尝试匹配每个流经此处的报文，一旦匹配成功，则由规则后面指定的处理动作进行处理； 那么我们来通俗的解释一下什么是iptables的规则，之前打过一个比方，每条”链”都是一个”关卡”，每个通过这个”关卡”的报文都要匹配这个关卡上的规则，如果匹配，则对报文进行对应的处理，比如说，你我二人此刻就好像两个”报文”，你我二人此刻都要入关，可是城主有命，只有器宇轩昂的人才能入关，不符合此条件的人不能入关，于是守关将士按照城主制定的”规则”，开始打量你我二人，最终，你顺利入关了，而我已被拒之门外，因为你符合”器宇轩昂”的标准，所以把你”放行”了，而我不符合标准，所以没有被放行，其实，”器宇轩昂”就是一种”匹配条件”，”放行”就是一种”动作”，”匹配条件”与”动作”组成了规则。 规则由 匹配条件 和 处理动作 组成匹配条件匹配条件分为基本匹配条件与扩展匹配条件 基本匹配条件：源地址Source IP，目标地址 Destination IP 上述内容都可以作为基本匹配条件。 扩展匹配条件：除了上述的条件可以用于匹配，还有很多其他的条件可以用于匹配，这些条件泛称为扩展条件，这些扩展条件其实也是netfilter中的一部分，只是以模块的形式存在，如果想要使用这些条件，则需要依赖对应的扩展模块。 源端口Source Port, 目标端口Destination Port 上述内容都可以作为扩展匹配条件 处理动作一些常用的动作： ACCEPT：允许数据包通过。 DROP：直接丢弃数据包，不给任何回应信息，这时候客户端会感觉自己的请求泥牛入海了，过了超时时间才会有反应。 REJECT：拒绝数据包通过，必要时会给数据发送端一个响应的信息，客户端刚请求就会收到拒绝的信息。 SNAT：源地址转换，解决内网用户用同一个公网地址上网的问题。 MASQUERADE：是SNAT的一种特殊形式，适用于动态的、临时会变的ip上。 DNAT：目标地址转换。 REDIRECT：在本机做端口映射。 LOG：在&#x2F;var&#x2F;log&#x2F;messages文件中记录日志信息，然后将数据包传递给下一条规则，也就是说除了记录以外不对数据包做任何其他操作，仍然让下一条规则去匹配。 ★,°:.☆(￣▽￣)&#x2F;$:.°★ 。","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiang07shuai06.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"iptables","slug":"iptables","permalink":"https://jiang07shuai06.github.io/tags/iptables/"}],"author":"byte76"},{"title":"HTTP基础概念","slug":"HTTP","date":"2024-12-24T02:37:22.519Z","updated":"2024-12-24T12:30:31.672Z","comments":true,"path":"2024/12/24/HTTP/","permalink":"https://jiang07shuai06.github.io/2024/12/24/HTTP/","excerpt":"","text":"HTTP超文本传输协议（HTTP）是一个用于传输超媒体文档（例如HTML）的应用层协议。它是为了Web浏览器与Web服务器之间的通信而设计的，但也可以用于其他目的（例如API通信）。HTTP是无状态协议，这意味着服务器不会在两个请求之间保留任何数据（状态）。 什么是HTTP请求？HTTP请求是客户端（比如浏览器）向服务器请求获取资源（如网页、图片、文件等）时发送的消息。包含如下几个关键部分： 请求行：包含请求方法（如 GET 用于获取资源、POST用于提交数据）、请求的 URL（统一资源定位符，指定要访问的资源位置）和 HTTP 协议版本。 请求头：包含一些额外的信息，像用户代理（表明请求的客户端类型）、接受的内容类型（如接受 HTML、JSON 等）、缓存控制信息等，用于告诉服务器更多关于请求的细节。 请求体（可选）：主要用于 POST 等请求方法，在其中放置要发送给服务器的数据，例如表单数据。 首先要明确，不是所有的 HTTP 请求方法都使用请求体。最常用于发送请求体的方法是 POST 和 PUT。 POST 方法通常用于向服务器提交数据来创建新的资源。例如，当用户在网页上填写一个注册表单并提交时，浏览器会使用 POST 方法将表单数据发送到服务器的注册接口。 PUT 方法主要用于更新服务器上已有的资源。假设一个在线文档编辑应用，用户修改了文档内容后，点击保存，应用可能会使用 PUT 方法将更新后的文档内容发送到服务器来更新文档资源。 http请求方法在 HTTP 通信过程中，每个 HTTP请求报文中都会包含一个 HTTP请求方法，用于告知客户端向服务器端请求执行某些具体的操作，下面列举几项常用的 HTTP请求方法 HTTP 请求方法 描述 GET 用于客户端请求指定资源信息，并返回指定资源实体 HEAD 和 GET 相似，但其不需要服务器响应请求的资源，而返回响应首部（只需要响应首部即可，就是告诉我有或者没有，不需要缓存界面给我） POST 基于HTML表单向服务器提交数据，服务i去通常需要存储此数据，通常存放在 MySQL 这种关系型数据库中 PUT 与 GET 相反，是向服务器发送资源的，服务器通常需要存储次资源，这就好比你要把一个新的商品送到商店并让商店存储起来。 DELETE 请求服务器端删除URL指定的资源 MOVE 请求服务器将指定的页面移至另一个网络地址 OPTIONS 探测服务器端对请求的URL所支持使用的请求方法 TRACE 跟踪一次请求中间所经历的代理服务器、防火墙或网关等。主要用于调试。 扩展：推荐一款功能强大的的 API开发和测试工具—— postman http协议版本http 0.9：最初的版本，仅支持 GET 方法，主要用于获取 HTML 文档，没有其他的概念，响应也很简单，只会返回 HTML 文档内容，没有状态码、响应头这些内容。 http 1.0：相较于0.9版本新增了多种请求方法，如 POST、HEAD等。引入了请求头和响应头，用于传递关于请求和响应的更多信息；例如，通过请求头中的 “Accept” 字段，客户端可以告诉服务器它能够接受的内容类型；响应头中的 “Content - Type” 字段则告知客户端返回内容的类型。支持多种内容类型，包括文本、图像、音频等多种格式的文件传输。 http 1.1： 目前广泛使用的版本之一，在1.0版本中，每次请求&#x2F;响应完成后，连接就会关闭。而1.1版本中允许在一次 TCP 连接中进行多次请求&#x2F;响应，减少了建立和关闭连接的开销，提高了网络传输效率。新增了更多的请求方法，如 PUT、DELETE 等。引入了管道化技术，允许客户端在等待一个请求的响应时发送下一个请求。不过，管道化在实际应用中因为一些复杂的原因（如请求顺序依赖等）没有得到广泛使用。 http 2.0：采用二进制格式进行数据传输，相比于1.1版本的文本格式，二进制格式更高效，解析速度更快。支持头部压缩，通过通过 HPB 算法压缩头部，减少传输量。多路复用是2.0版本的核心特性之一，它允许在一个 TCP 连接上同时传输多个请求和响应，这些请求和响应可以交错进行，而不需要像1.1版本那样排队等待。 什么是 HTTP 响应？HTTP 响应是服务器对客户端 HTTP 请求的回复消息。当客户端（如浏览器）向服务器发送请求，请求获取网页、文件或执行某种操作后，服务器会处理该请求，并返回一个 HTTP 响应来告知客户端请求的结果。组成部分：状态码：这是 HTTP 响应中非常关键的部分，它是一个三位数字的代码，用于表示服务器对请求的处理状态。例如，最常见的状态码 200，表示请求成功，服务器已成功处理并返回请求的资源。而 404 状态码则表示请求的资源未找到，可能是客户端请求的 URL 有误或者服务器上不存在该资源。另外还有 500 状态码，通常意味着服务器在处理请求时发生了内部错误。 响应头：响应头包含了关于响应的各种附加信息。比如 “Content - Type” 字段，它告诉客户端返回内容的类型，如 “text&#x2F;html” 表示返回的是 HTML 文档，“application&#x2F;json” 表示返回的是 JSON 格式的数据。还有 “Content - Length” 字段，用于指示响应体的长度（字节数）。此外，响应头还可能包含缓存控制信息（如 “Cache - Control”），用于指导客户端是否缓存以及如何缓存响应内容。 响应体：响应体是服务器返回的实际内容，是客户端真正需要的部分。如果客户端请求的是一个网页，那么响应体就是网页的 HTML 代码；如果请求的是一张图片，响应体就是图片的二进制数据；若请求的是一个 API 接口获取数据，响应体可能是 JSON 或 XML 格式的数据，这些数据包含了客户端所请求的信息。 http的状态码 状态码 说明 1XX 信息性状态码 2XX 成功状态码 3XX 重定向状态码 4XX 客户端错误 5XX 服务端错误 Web客户端访问Web服务器的工作流程（以网络浏览器为例）导航和启动用户在浏览器中输入网址或者点击其他通信中的链接后，浏览器通过 DNS 查找网址并将请求发送到该网址 客户端向服务器发送 HTTP 请求报文客户端（如浏览器）构建一个请求报文发送给 Web 服务器，请求报文的第一行标识了网站的根页面，指示了HTTP的版本（1.1&#x2F;1.0&#x2F;…），还有请求实体（如浏览器）的信息。请求报文发送到Web服务器后，即可由服务器读取并生成响应。 服务器将 HTTP 响应发回给客户端Web服务器收到请求后，就会生成响应报文并将其返回给浏览器（客户端），浏览器接收并读取响应报文。报文的第一行通常是响应代码如 “200 OK”，表示 Web服务器可以成功响应请求。HTTP响应报文确切再现了请求报文的格式，并包含一系列成为“响应标头”的行，这些行提供有关响应的信息。 浏览器呈现报文浏览器呈现响应报文，并在浏览器中显示网页 衡量一个 web网址的访问量指标：pv、uv、ippv：网站的点击量uv：网站的访问用户数——COOKIE，cookie值相同的表示是一个用户ip：网站的访问ip数，即有多少台客户机访问","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiang07shuai06.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"网络协议","slug":"网络协议","permalink":"https://jiang07shuai06.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}],"author":"byte76"},{"title":"Hexo+Github==>个人博客","slug":"Hexo-Github-个人博客","date":"2024-10-20T08:17:35.000Z","updated":"2024-12-29T03:34:58.470Z","comments":true,"path":"2024/10/20/Hexo-Github-个人博客/","permalink":"https://jiang07shuai06.github.io/2024/10/20/Hexo-Github-%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"这篇文章是对于使用 hexo 和 github 搭建个人博客的思路梳理1、下载 node.jshttps://nodejs.org/zh-cn 2、下载 githttps://git-scm.com/downloads 验证是否下载成功，管理员运行 cmd 输入以下三条命令 123node -vnpm -vgit -v 3、下载 hexo1npm install hexo-cli -g 4、搭建仓库名称格式：仓库名称.github.io 勾选 Public 勾选 Add a README file 拉到下面点击 create 创建 5、生成SSH Keys进入任意文件夹，右键空白处然后点Git bash here,输入 1ssh-keygen -t rsa -C &quot;邮件地址&quot; 然后敲4次Enter⌨️然后进入C:\\Users\\用户名，在里面进入.ssh文件用记事本打开里面的id_rsa.pub,全选复制里面的代码然后打开github进入用户设置，找到SSH keys新建SSH keys，名称随意，在下面粘贴代码，然后创建测试是否成功在git bash中输入 1ssh -T git@github.com 回车，然后再输入 yes 6、本地部署在喜欢位置新建文件Blog，然后进入文件夹右键空白处然后点 Git bash here，输入 1hexo init 然后依次输入 12hexo g # 生成hexo s # 预览 （如果不成功的话就重复直到成功，因为国内与github连接不稳定）现在就可以复制生成的链接进入浏览器看到我们生成的本地服务器了然后回到命令行，ctrl+c 关闭 7、上线博客进入之前的Blog文件夹，用记事本打开_config.yml编辑 url 段落 123# URL## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;url: https://Jiang07Shuai06.github.io 拉到最下面将deploy后面的全删掉，复制粘贴这段 123type: gitrepository: branch: main 注意缩进格式：每行前面都有两个空格不要删，每个冒号后面都有个空格也不要删！去 github 之前生成的仓库页面，点 code，复制 https链接将其粘贴到我们记事本中的 repository：后面然后保存退出回到博客文件夹，git bash安装自动部署发布工具 1npm install hexo-deployer-git --save 然后在Blog文件夹右键打开git bash，依次输入 12hexo g # 生成hexo d # 上传 如果是第一次使用git的话会需要配置git config --global user.email &quot;你的邮箱&quot;git config --global user.name &quot;你的名字&quot;配置完后再 hexo d 上传在跳出来的窗口内进行登录接下来我们就成功把本地内容上传到github了上传成功以后，我们就算搭建好了！上自己的网址看看吧网址是我们之前设的仓库名：用户名.github.io 文章参考🔗：https://blog.fiveth.cc/p/bb32/#%E5%87%86%E5%A4%87%E5%B7%A5%E5%85%B7","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiang07shuai06.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"博客","slug":"博客","permalink":"https://jiang07shuai06.github.io/tags/%E5%8D%9A%E5%AE%A2/"}]},{"title":"天气预报自动推送","slug":"天气预报推送","date":"2024-10-07T09:29:17.000Z","updated":"2024-10-26T02:34:44.175Z","comments":true,"path":"2024/10/07/天气预报推送/","permalink":"https://jiang07shuai06.github.io/2024/10/07/%E5%A4%A9%E6%B0%94%E9%A2%84%E6%8A%A5%E6%8E%A8%E9%80%81/","excerpt":"","text":"一、申请微信测试公众号（https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login） 获取到这四个值 appID, appSecret, openId, template_id 想让谁收消息，谁就用微信扫二维码，刷新页面后即出现在用户列表，获取微信号（openId） 新增测试模板获得 template_id（模板ID） 天气模板： 123456今天：&#123;&#123;date.DATA&#125;&#125;地区：&#123;&#123;region.DATA&#125;&#125;天气：&#123;&#123;weather.DATA&#125;&#125;气温：&#123;&#123;temp.DATA&#125;&#125;风向：&#123;&#123;wind_dir.DATA&#125;&#125;对你说的话：&#123;&#123;today_note.DATA&#125;&#125; 课程表模板： 1消息：&#123;&#123;message.DATA&#125;&#125; 二、配置代码 将上面获得的几个值填入代码这几行，启动即可 12345678appID = &quot;&quot;appSecret = &quot;&quot;#收信人ID即 用户列表中的微信号，见上文openId = &quot;&quot;# 天气预报模板IDweather_template_id = &quot;&quot;# 时间表模板IDtimetable_template_id = &quot;&quot; 定时任务（根据需求进行修改这几行） 12345schedule.every().day.at(&quot;08:00&quot;).do(weather_report, &quot;北京&quot;)# schedule.every().monday.at(&quot;13:30&quot;).do(timetable, &quot;还有15分钟开始下午的课程&quot;)while True: schedule.run_pending() time.sleep(1) 完成代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166# 安装依赖 pip3 install requests html5lib bs4 scheduleimport timeimport requestsimport jsonimport schedulefrom bs4 import BeautifulSoup# 从测试号信息获取appID = &quot;wx1c904b832908e3d7&quot;appSecret = &quot;024e7a99b9bd93e4ec2ba0e61cb99869&quot;#收信人ID即 用户列表中的微信号，见上文openId = &quot;oLg156sEhzpHX3f6OKG6HaCTid9s&quot;# 天气预报模板IDweather_template_id = &quot;T00eYDomN3GOBXOTqTYhX27Nqp-vCdDO2xHKAK1ElH8&quot;# 时间表模板IDtimetable_template_id = &quot;kg29LwRP6--uo6Xq3mm-aRyJFaF_Pe2SsnUjYq23YpA&quot;def get_weather(my_city): urls = [&quot;http://www.weather.com.cn/textFC/hb.shtml&quot;, &quot;http://www.weather.com.cn/textFC/db.shtml&quot;, &quot;http://www.weather.com.cn/textFC/hd.shtml&quot;, &quot;http://www.weather.com.cn/textFC/hz.shtml&quot;, &quot;http://www.weather.com.cn/textFC/hn.shtml&quot;, &quot;http://www.weather.com.cn/textFC/xb.shtml&quot;, &quot;http://www.weather.com.cn/textFC/xn.shtml&quot; ] for url in urls: resp = requests.get(url) text = resp.content.decode(&quot;utf-8&quot;) soup = BeautifulSoup(text, &#x27;html5lib&#x27;) div_conMidtab = soup.find(&quot;div&quot;, class_=&quot;conMidtab&quot;) tables = div_conMidtab.find_all(&quot;table&quot;) for table in tables: trs = table.find_all(&quot;tr&quot;)[2:] for index, tr in enumerate(trs): tds = tr.find_all(&quot;td&quot;) # 这里倒着数，因为每个省会的td结构跟其他不一样 city_td = tds[-8] this_city = list(city_td.stripped_strings)[0] if this_city == my_city: high_temp_td = tds[-5] low_temp_td = tds[-2] weather_type_day_td = tds[-7] weather_type_night_td = tds[-4] wind_td_day = tds[-6] wind_td_day_night = tds[-3] high_temp = list(high_temp_td.stripped_strings)[0] low_temp = list(low_temp_td.stripped_strings)[0] weather_typ_day = list(weather_type_day_td.stripped_strings)[0] weather_type_night = list(weather_type_night_td.stripped_strings)[0] wind_day = list(wind_td_day.stripped_strings)[0] + list(wind_td_day.stripped_strings)[1] wind_night = list(wind_td_day_night.stripped_strings)[0] + list(wind_td_day_night.stripped_strings)[1] # 如果没有白天的数据就使用夜间的 temp = f&quot;&#123;low_temp&#125;——&#123;high_temp&#125;摄氏度&quot; if high_temp != &quot;-&quot; else f&quot;&#123;low_temp&#125;摄氏度&quot; weather_typ = weather_typ_day if weather_typ_day != &quot;-&quot; else weather_type_night wind = f&quot;&#123;wind_day&#125;&quot; if wind_day != &quot;--&quot; else f&quot;&#123;wind_night&#125;&quot; return this_city, temp, weather_typ, winddef get_access_token(): # 获取access token的url url = &#x27;https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=&#123;&#125;&amp;secret=&#123;&#125;&#x27; \\ .format(appID.strip(), appSecret.strip()) response = requests.get(url).json() print(response) access_token = response.get(&#x27;access_token&#x27;) return access_tokendef get_daily_love(): # 每日一句情话 url = &quot;https://api.lovelive.tools/api/SweetNothings/Serialization/Json&quot; r = requests.get(url) all_dict = json.loads(r.text) sentence = all_dict[&#x27;returnObj&#x27;][0] daily_love = sentence return daily_lovedef send_weather(access_token, weather): # touser 就是 openID # template_id 就是模板ID # url 就是点击模板跳转的url # data就按这种格式写，time和text就是之前&#123;&#123;time.DATA&#125;&#125;中的那个time，value就是你要替换DATA的值 import datetime today = datetime.date.today() today_str = today.strftime(&quot;%Y年%m月%d日&quot;) body = &#123; &quot;touser&quot;: openId.strip(), &quot;template_id&quot;: weather_template_id.strip(), &quot;url&quot;: &quot;https://weixin.qq.com&quot;, &quot;data&quot;: &#123; &quot;date&quot;: &#123; &quot;value&quot;: today_str &#125;, &quot;region&quot;: &#123; &quot;value&quot;: weather[0] &#125;, &quot;weather&quot;: &#123; &quot;value&quot;: weather[2] &#125;, &quot;temp&quot;: &#123; &quot;value&quot;: weather[1] &#125;, &quot;wind_dir&quot;: &#123; &quot;value&quot;: weather[3] &#125;, &quot;today_note&quot;: &#123; &quot;value&quot;: get_daily_love() &#125; &#125; &#125; url = &#x27;https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=&#123;&#125;&#x27;.format(access_token) print(requests.post(url, json.dumps(body)).text)def send_timetable(access_token, message): body = &#123; &quot;touser&quot;: openId, &quot;template_id&quot;: timetable_template_id.strip(), &quot;url&quot;: &quot;https://weixin.qq.com&quot;, &quot;data&quot;: &#123; &quot;message&quot;: &#123; &quot;value&quot;: message &#125;, &#125; &#125; url = &#x27;https://api.weixin.qq.com/cgi-bin/message/template/send?access_token=&#123;&#125;&#x27;.format(access_token) print(requests.post(url, json.dumps(body)).text)def weather_report(city): # 1.获取access_token access_token = get_access_token() # 2. 获取天气 weather = get_weather(city) print(f&quot;天气信息： &#123;weather&#125;&quot;) # 3. 发送消息 send_weather(access_token, weather)def timetable(message): # 1.获取access_token access_token = get_access_token() # 3. 发送消息 send_timetable(access_token, message)if __name__ == &#x27;__main__&#x27;: weather_report(&quot;河北&quot;) # timetable(&quot;第二教学楼十分钟后开始英语课&quot;) # schedule.every().day.at(&quot;08:00&quot;).do(weather_report, &quot;北京&quot;) # schedule.every().monday.at(&quot;13:30&quot;).do(timetable, &quot;还有15分钟开始下午的课程&quot;) #while True: # schedule.run_pending() # time.sleep(1) 原创文档链接：https://www.bilibili.com/read/cv28928153/ 原创视频链接：https://www.bilibili.com/video/BV1Ng4y1r7EP/?spm_id_from=333.880.my_history.page.click&amp;vd_source=576ff0210b33e8823a0a538d3f79f11f","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiang07shuai06.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://jiang07shuai06.github.io/tags/Python/"}]},{"title":"外星人入侵","slug":"外星人入侵","date":"2024-10-04T11:05:33.000Z","updated":"2024-10-26T02:30:49.441Z","comments":true,"path":"2024/10/04/外星人入侵/","permalink":"https://jiang07shuai06.github.io/2024/10/04/%E5%A4%96%E6%98%9F%E4%BA%BA%E5%85%A5%E4%BE%B5/","excerpt":"","text":"遇到的问题及注意事项： 编写计分模块 scoreborad.py 时，变量引用错误，没搞清楚使用的是值传递还是引用传递 参考链接 https://blog.csdn.net/hohaizx/article/details/78427406 飞船数量与设置模块 settings.py 中的飞船设置相关 外星人、子弹、飞船移动速度以及幅度与设置模块 settings.py 中的 initialize_dynamic_settings 函数设置相关 参考资料及源码： 参考书籍《Python编程——从入门到实践》 参考教程链接 https://www.modb.pro/db/49581 通过百度网盘分享的文件：alien_invasion_2.0.zip 链接：https://pan.baidu.com/s/1NTkG7Mk_5sw4uzQLVU8ieQ?pwd=byte 提取码：byte","categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiang07shuai06.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://jiang07shuai06.github.io/tags/Python/"}]}],"categories":[{"name":"技术分享","slug":"技术分享","permalink":"https://jiang07shuai06.github.io/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"}],"tags":[{"name":"云上安全","slug":"云上安全","permalink":"https://jiang07shuai06.github.io/tags/%E4%BA%91%E4%B8%8A%E5%AE%89%E5%85%A8/"},{"name":"Redis","slug":"Redis","permalink":"https://jiang07shuai06.github.io/tags/Redis/"},{"name":"MySQL","slug":"MySQL","permalink":"https://jiang07shuai06.github.io/tags/MySQL/"},{"name":"堡垒机","slug":"堡垒机","permalink":"https://jiang07shuai06.github.io/tags/%E5%A0%A1%E5%9E%92%E6%9C%BA/"},{"name":"iptables","slug":"iptables","permalink":"https://jiang07shuai06.github.io/tags/iptables/"},{"name":"网络协议","slug":"网络协议","permalink":"https://jiang07shuai06.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"博客","slug":"博客","permalink":"https://jiang07shuai06.github.io/tags/%E5%8D%9A%E5%AE%A2/"},{"name":"Python","slug":"Python","permalink":"https://jiang07shuai06.github.io/tags/Python/"}]}